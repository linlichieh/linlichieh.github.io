<!DOCTYPE html>
<html lang="en-us">
<title>Database - MySQL Optimisation | Software engineering notes</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.104.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/index.css">
<link rel="canonical" href="/posts/database-mysql-optimisation/">
<link rel="alternate" type="application/rss+xml" href="" title="Software engineering notes">

<header>
  
    <a href="/" class="title">Software engineering notes</a>
  
  
</header>

<article>
  <header>
    <h1>Database - MySQL Optimisation</h1>
    
  </header>
  <h1 id="index">Index</h1>
<h3 id="how-does-index-work">How does index work?</h3>
<p>MySQL uses a data structure (B-Tree is default) that stores the value of the indexed column(s)
and a reference to the row that contains the rest of the data.
This allows mysql to find the values without scanning the whole table.</p>
<ul>
<li>B-Tree is the most commonly used</li>
<li>B-Tree is used for both clustered and non-clustered indexes</li>
<li>If it&rsquo;s a multi-column index, the value will be concatenated values of the indexed columns</li>
</ul>
<p>types of index</p>
<ul>
<li>B-Tree
<ul>
<li>efficient for finding ranges of values and individual values, especially when dealing with <code>=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>BETWEEN</code>, <code>LIKE</code>, etc.</li>
</ul>
</li>
<li>Hash
<ul>
<li>used for equality comparisons that use the <code>=</code> operator</li>
<li>not used for range-based query or sorting (<code>ORDER BY</code>)</li>
</ul>
</li>
<li>Full-text
<ul>
<li>used with full-text search functions <code>MATCH()</code>, <code>AGAINST()</code></li>
<li>used for complex word-based searches</li>
</ul>
</li>
<li>Spatial
<ul>
<li>used for geographic or multi-dimensional data</li>
<li>used for finding points within a given radius or polygons that overlap</li>
</ul>
</li>
<li>Clustered
<ul>
<li>stored as B-tree</li>
<li>the primary key serves as a clustered index</li>
<li>mysql can have only one clustered index in a table</li>
<li>It&rsquo;s best for retrieving records in a range of values</li>
</ul>
</li>
<li>Secondary (Non-clustered)
<ul>
<li>stored as B-tree</li>
<li>an index that isnâ€™t a table&rsquo;s primary key index (which is a clustered index)</li>
<li>contain the indexed columns&rsquo; values and a pointer that references the primary key for the row</li>
<li>best for retrieving individual records</li>
</ul>
</li>
</ul>
<h3 id="multi-column-index-best-practices">Multi-column index best practices</h3>
<p>Most selective</p>
<ul>
<li>If one column in the index is going to narrow down the result significantly more than the other, it should be placed first in the index</li>
</ul>
<p>Column order Matters</p>
<ul>
<li>For example, if there is an index on (uid, gid, pid),</li>
<li>the index will fully come into effect under the following cases:
<ul>
<li>uid = &ldquo;AAA&rdquo;</li>
<li>uid = &ldquo;AAA&rdquo; AND gid = &ldquo;BBB&rdquo;</li>
<li>uid = &ldquo;AAA&rdquo; AND gid = &ldquo;BBB&rdquo; AND pid = &ldquo;CCC&rdquo;</li>
</ul>
</li>
<li>the index will partially come into effect under the following cases:
<ul>
<li>uid = &ldquo;AAA&rdquo; AND pid = &ldquo;CCC&rdquo;</li>
<li>only uid comes into effect in this index</li>
</ul>
</li>
<li>the index won&rsquo;t come into effect under the following cases:
<ul>
<li>gid = &ldquo;BBB&rdquo;</li>
<li>pid = &ldquo;CCC&rdquo;</li>
<li>gid = &ldquo;BBB&rdquo; AND pid = &ldquo;CCC&rdquo;</li>
</ul>
</li>
<li>the reason why the index won&rsquo;t work is because the index followed by uid that isn&rsquo;t in the WHERE clause</li>
</ul>
<h3 id="does-the-order-matter-in-where-clauses">Does the order matter in &ldquo;WHERE&rdquo; clauses?</h3>
<p>No, the order of where clauses does not matter.</p>
<p>Query optimizer will look at all the parts of the WHERE clause and figure out the most efficient way to satisfy that query</p>
<h3 id="can-a-query-choose-more-than-one-index">Can a query choose more than one index?</h3>
<p>Yes, a query optimizer can choose to use more than one index in a single query if doing so would make the query more efficient.</p>
<p>It&rsquo;s worth noting that using multiple indexes in a single query can also have downsides.
Each index lookup has a cost, and the database has to combine the results from multiple lookups, which also takes time.
Therefore, the query optimizer will only choose to use multiple indexes if it estimates that doing so will be faster than the alternatives.
This estimation is based on various factors, such as the size of the table, the selectivity of the indexes, and the complexity of the query.</p>
<p>For example, if there are two indexes, one for &lsquo;uid&rsquo; and another for &lsquo;pid&rsquo;, and both are used for filtering in the WHERE clause, will the query optimizer use both indexes?</p>
<p>It depends. The query optimizer may use both indexes if both &lsquo;uid&rsquo; and &lsquo;pid&rsquo; columns are used in the WHERE clause and their indexes are highly selective.
However, it may also choose to use only one index which is more selective than the other one.</p>
<h3 id="can-an-index-be-used-for-both-order-by-and-where-at-the-same-time">Can an index be used for both <code>ORDER BY</code> and <code>WHERE</code> at the same time?</h3>
<p>Yes, a multi-column index can be used for both <code>WHERE</code> and <code>ORDER BY</code> at the same time.</p>
<p>The index needs to be carefully designed so that the fields used in the WHERE clause and the ORDER BY clause match the prefix of the multi-column index.</p>
<p>For example:</p>
<pre><code>SELECT * FROM employees WHERE last_name = 'Bob' ORDER BY created_at;

index: last_name, created_at
</code></pre>
<p>The index can be used for both <code>WHERE</code>, searching the leftmost part of the index (<code>last_name = bob</code>), and the <code>ORDER BY</code>, mainting the order of <code>created_at</code> in the filtered data</p>
<h3 id="what-factors-does-the-query-optimizer-consider-when-making-decisions-on-index">What factors does the query optimizer consider when making decisions on index?</h3>
<ul>
<li>Cardinality
<ul>
<li>The uniqueness of data in a column.</li>
<li>If a column has a high cardinality (many unique values), then an index on that column can be very efficient for certain lookups.</li>
<li>Conversely, if a column has low cardinality (few unique values), then an index might not be as useful.</li>
</ul>
</li>
<li>Selectivity
<ul>
<li>This is related to cardinality and refers to the percentage of rows a particular index entry selects.</li>
<li>If an index entry refers to many rows (low selectivity), the optimizer may choose a table scan or another index.</li>
<li>But if an index entry refers to few rows (high selectivity), the optimizer may opt to use the index.</li>
<li>If there is a choice between multiple indexes, MySQL normally uses the index that finds the smallest number of rows (the most selective index)</li>
</ul>
</li>
<li>Distribution of Values
<ul>
<li>If the values in a column are unevenly distributed, this might affect the optimizer&rsquo;s decision.</li>
<li>For instance, if a large number of rows have the same value for an indexed column, and a query is selecting rows with that value, a full table scan might be more efficient than using the index.</li>
</ul>
</li>
<li>Size of the Table
<ul>
<li>Larger tables are more likely to benefit from indexing than smaller tables.</li>
<li>In a small table, it might be quicker to perform a full table scan rather than using an index.</li>
</ul>
</li>
<li>Type of Query
<ul>
<li>The kind of operation being performed in the query can also influence the decision.</li>
<li>For instance, indexes are more beneficial in <code>SELECT</code> queries than in <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> queries, because the latter group of operations require additional time to update the index.</li>
</ul>
</li>
<li>Index Type
<ul>
<li>Different DBMS support different types of indexes (B-tree, hash, bitmap, etc.).</li>
<li>The type of an index can determine its usefulness for certain types of queries.</li>
</ul>
</li>
<li>Statistics
<ul>
<li>Modern databases keep statistics about data distribution in tables and indexes.</li>
<li>The optimizer uses these to make educated decisions about which indexes to use.</li>
</ul>
</li>
</ul>
<h3 id="whats-covering-index">What&rsquo;s covering index?</h3>
<p>A covering index in MySQL is a type of index that includes all the fields retrieved by a particular query.
if a query can be satisfied entirely using an index without having to perform additional disk I/O operation to fetch the actual data row.</p>
<p>For example:</p>
<pre><code>SELECT first_name, last_name FROM users WHERE email = 'user@example.com';
CREATE INDEX idx_email_first_last ON users(email, first_name, last_name);
</code></pre>
<p>This index &ldquo;covers&rdquo; the query because the index includes all the fields used in this query.</p>
<p>Any single-column index or multi-column index could act as a covering index, given the right query.
Design your indexes and queries to take advantage of this optimization technique wherever possible.</p>
<h3 id="which-clauses-in-a-query-can-affect-the-query-optimizers-decision-on-indexes">Which clauses in a query can affect the query optimizer&rsquo;s decision on indexes?</h3>
<ul>
<li><code>SELECT</code>
<ul>
<li>While the SELECT clause doesn&rsquo;t directly affect index selection, the columns that are being selected can influence the optimizer.</li>
<li>If all selected columns are part of a single index (a situation known as a &ldquo;covering index&rdquo;), the optimizer may choose to scan the index instead of the actual table.</li>
</ul>
</li>
<li><code>JOIN</code>
<ul>
<li>The optimizer takes into account the tables being joined and the join type.</li>
<li>If there are indexes on the columns being used to join the tables, the optimizer will likely use those indexes to speed up the join operation.</li>
</ul>
</li>
<li><code>WHERE</code>
<ul>
<li>The optimizer looks at the columns and values in the WHERE clause.</li>
<li>If there are indexes on the columns being used in the WHERE conditions, it can use these indexes to quickly locate the rows that match the condition, instead of scanning the entire table.</li>
</ul>
</li>
<li><code>GROUP BY</code>: If you&rsquo;re grouping by a column that&rsquo;s indexed, the optimizer might use the index to speed up the operation.</li>
<li><code>ORDER BY</code>: If you&rsquo;re ordering by a column that&rsquo;s indexed, the database can use the index to avoid having to sort the result set, since the index already provides a sorted set of values.</li>
<li><code>LIMIT</code>: The LIMIT clause can significantly influence how the optimizer chooses to use indexes, especially when combined with an ORDER BY clause.</li>
</ul>
<h3 id="which-clauses-are-given-precedence-over-others-by-the-query-optimizer-within-a-query">Which clauses are given precedence over others by the query optimizer within a query?</h3>
<p>No clause takes precedence over the others.</p>
<p>When deciding on the usage of indexes, the optimizer doesn&rsquo;t strictly prioritize one clause over the other.</p>
<p>For example, it doesn&rsquo;t necessarily favor &lsquo;WHERE&rsquo; over &lsquo;ORDER BY&rsquo;.
It evaluates the entire query and the available indexes to choose the best indexes to use.</p>
<h3 id="the-pros-and-cons-of-setting-foreign-keys">The pros and cons of setting foreign keys</h3>
<p>Setting foreign keys in a database comes with several advantages and a few considerations. Here are some pros and cons of setting foreign keys:</p>
<p>Pros</p>
<ul>
<li>Data Integrity
<ul>
<li>ensure that relationships between tables are maintained correctly</li>
<li>prevent the insertion of invalid or orphaned data by enforcing constraints on the referenced columns</li>
</ul>
</li>
<li>Data Consistency
<ul>
<li>automatically update or delete related records when changes are made to the referenced records</li>
<li>minimise manual errors and inconsistencies</li>
</ul>
</li>
<li>Query Optimization
<ul>
<li>optimise JOIN operations through efficient navigation between related tables using indexes.</li>
</ul>
</li>
<li>Documentation and Understanding
<ul>
<li>illustrate relationships between tables</li>
<li>serve as guides, making database structure easier to understand</li>
</ul>
</li>
</ul>
<p>Cons</p>
<ul>
<li>Performance Overhead
<ul>
<li>Validation Checks
<ul>
<li>For inserts and updates, the database must ensure that the referenced key value exists in the referenced table</li>
<li>For deletes, the database must verify if there are any dependent records in the child table</li>
</ul>
</li>
<li>Index maintenance
<ul>
<li>maintain and update referencing and referenced indexes</li>
</ul>
</li>
<li>Bulk Data Operations:
<ul>
<li>operations such as concurrent updates and transactions to large-scale tables</li>
</ul>
</li>
<li>Concurrency and Locking
<ul>
<li>For updates and deletes, system performance and concurrency can be impacted due to lock operations on related tables</li>
</ul>
</li>
</ul>
</li>
<li>Complexity and Maintenance
<ul>
<li>For database schema, any modifications to relationships or referenced tables may require updating the foreign keys</li>
<li>When performing database migrations or large-scale data loading, foreign key constraints can sometimes pose challenges.
<ul>
<li>Workaround: Disabling or temporarily removing foreign key constraints may be necessary to facilitate the migration or data loading process</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>the benefits of setting foreign keys typically outweigh the drawbacks</p>
</blockquote>
<h3 id="how-to-speed-up-like-query-by-using-an-index">How to speed up <code>LIKE</code> query by using an index?</h3>
<p>For string columns, MySQL indexes the left side of a string</p>
<p>It can speed up <code>like</code> query that has a wildcard on the right side</p>
<pre><code>SELECT * FROM foo WHERE field LIKE &quot;bar%&quot;
</code></pre>
<p>It doesn&rsquo;t work for a query that has a wildcard on the left side</p>
<pre><code>SELECT * FROM foo WHERE field LIKE &quot;%bar%&quot;
</code></pre>
<h1 id="explain">EXPLAIN</h1>
<h3 id="the-columns-in-the-output">The columns in the output</h3>
<ul>
<li>id
<ul>
<li>The ID of the select operation within the query execution plan. If there are multiple rows, they represent a nested subquery</li>
</ul>
</li>
<li>select_type
<ul>
<li>The type of select operation being performed. It indicates the type of query or subquery, such as <code>SIMPLE</code>, <code>PRIMARY</code>, <code>SUBQUERY</code>, <code>DERIVED</code>, etc.</li>
<li>Values
<ul>
<li><code>SIMPLE</code>: A simple <code>SELECT</code> statement without any subqueries or <code>UNION</code>s.</li>
<li><code>PRIMARY</code>: The main select statement in a complex query (for example, outer query in a subquery).</li>
<li><code>SUBQUERY</code>: The first <code>SELECT</code> statement in a subquery, not in the <code>FROM</code>.
<ul>
<li>e.g. <code>SELECT * FROM users WHERE user_id in (SELECT id FROM employees)</code></li>
<li>select_type: <code>SUBQUERY</code>, table: <code>employees</code></li>
</ul>
</li>
<li><code>DERIVED</code>: MySQL creates a temporary table for the results of the <code>SELECT</code> statement. This is usually in <code>FROM</code> subqueries.
<ul>
<li>e.g. <code>SELECT * FROM ( SELECT column1, column2 FROM table1) as derived_table</code></li>
<li>select_type: <code>DERIVED</code>, table: <code>derived_table</code></li>
</ul>
</li>
<li><code>UNION</code>: A second or subsequent <code>SELECT</code> statement in a <code>UNION</code>.
<ul>
<li>e.g. show the result of the union of tables 1 and 2</li>
<li>e.g. <code>SELECT id FROM table1 UNION SELECT id FROM table2</code></li>
<li>select_type: <code>UNION</code>, table: <code>table2</code></li>
</ul>
</li>
<li><code>UNION RESULT</code>: The result of a <code>UNION</code>.
<ul>
<li>select_type: <code>UNION RESULT</code>, table: <code>&lt;union1,2&gt;</code></li>
</ul>
</li>
<li><code>DEPENDENT UNION</code>: A second or subsequent <code>SELECT</code> statement in a <code>UNION</code>, but depending on outer query.</li>
<li><code>DEPENDENT SUBQUERY</code>: A subquery that depends on the outer query.</li>
<li><code>MATERIALIZED</code>: It refers to a materialized subquery, which is a subquery that has been precomputed and stored.</li>
<li><code>UNCACHEABLE SUBQUERY</code>: A subquery result that is not cached and hence is re-evaluated for each row of the outer query.</li>
<li><code>UNCACHEABLE UNION</code>: The result of a <code>UNION</code> is not cached, and hence the <code>UNION</code> operation is re-evaluated for each row of the outer query.</li>
</ul>
</li>
</ul>
</li>
<li>table
<ul>
<li>The name of the table involved in the corresponding row of the query execution plan.</li>
</ul>
</li>
<li>partitions
<ul>
<li>The partitions of the table that are accessed or searched during the query execution.</li>
</ul>
</li>
<li>type
<ul>
<li>The join type or access method used for retrieving rows.</li>
<li>Values
<ul>
<li><code>const</code>
<ul>
<li>ideal value</li>
<li>This suggests that the query accesses a single row based on a constant value or a primary key.</li>
<li>It&rsquo;s the most efficient access method because it retrieves a specific row directly.</li>
<li>e.g. <code>SELECT * FROM employees WHERE employee_id = 1</code>, assuming <code>employee_id</code> is a primary key</li>
<li>e.g. <code>SELECT * FROM employees WHERE unique_index_column = 'unique_value'</code>, assuming <code>unique_index_column</code> is a column that has a unique index</li>
<li>e.g. <code>SELECT * FROM employees WHERE column1 = 'value1' AND column2 = 'value2'</code>, assuming <code>column1</code> and <code>column2</code> together form a composite unique index</li>
</ul>
</li>
<li><code>ALL</code>
<ul>
<li>This indicates a full table scan where all rows of the table are read.</li>
<li>It can be resource-intensive and generally not desirable, especially for large tables.</li>
<li>e.g. <code>SELECT * FROM employees WHERE name LIKE '%John%'</code></li>
</ul>
</li>
<li><code>index</code>
<ul>
<li>MySQL will scan the entire index to find matching rows</li>
<li>This happens when all the columns being selected are part of the same index.</li>
<li>MySQL can go directly to the index to find the necessary data, instead of searching the entire table.</li>
<li>It&rsquo;s more efficient than a full table scan (<code>ALL</code> type), but not efficient enough because it still reads the entire index</li>
<li>It&rsquo;s worth to note that this can happen even without a <code>WHERE</code> clause</li>
<li>e.g. <code>SELECT * FROM employees</code>, mysql may opt to perform a full index scan if that&rsquo;s cheaper than a full table scan
<ul>
<li>e.g. If there is a covering index that includes all the columns in the table, mysql might instead opt to do a full scan of that index</li>
</ul>
</li>
<li>e.g. <code>SELECT employee_name FROM employees</code>, assuming <code>employee_name</code> is an indexed column, mysql can simply scan the <code>employee_name</code> index to retrieve the data, rather than scanning the full table</li>
<li>e.g. <code>SELECT * FROM employees ORDER BY employee_name</code>, assuming <code>employee_name</code> is an indexed column, mysql performs an index scan to take advantage of the fact that the index stores rows in order</li>
</ul>
</li>
<li><code>range</code>
<ul>
<li>MySQL uses an index to read rows from a table based on a range</li>
<li>this type is used when querying on indexed columns with operators like <code>BETWEEN</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>IN</code>, etc.</li>
<li>much more efficient than <code>index</code> and <code>ALL</code> types because it only reads rows where the index is within a certain range, rather than reading the entire index or table</li>
<li>e.g. <code>SELECT * FROM employees WHERE employee_id BETWEEN 100 AND 200</code>, assuming <code>employee_id</code> is an indexed column</li>
</ul>
</li>
<li><code>index_merge</code>
<ul>
<li>Only appear if the optimizer decides to use the Index Merge optimization</li>
<li>Use multiple index scans and merges the results</li>
<li>e.g. <code>SELECT * FROM employees WHERE employee_id = 1 OR department_id = 2</code>, assuming <code>employee_id</code> and <code>department_id</code> are seperately indexed columns (not multi-column index)</li>
</ul>
</li>
<li><code>unique_subquery</code>
<ul>
<li>This value suggests that a subquery is used to fetch a single unique row.</li>
</ul>
</li>
<li><code>index_subquery</code>
<ul>
<li>Similar to <code>unique_subquery</code>, but tbl value inside the <code>IN</code> clause is non-unique.</li>
</ul>
</li>
<li><code>ref</code>
<ul>
<li>ideal value</li>
<li>This indicates that the query uses a non-unique index to access rows based on a single value from another table.</li>
<li>It typically occurs when joining tables using a column that is not unique but has an index.</li>
<li>e.g. JOIN on gid = gid (1:N)</li>
<li>e.g. <code>SELECT * FROM employees WHERE department_id = 10</code>, assuming <code>department_id</code> is a non-unique indexed column</li>
</ul>
</li>
<li><code>eq_ref</code>
<ul>
<li>ideal value</li>
<li>This is similar to <code>ref</code>, but it occurs when the join is performed using a unique index.</li>
<li>It&rsquo;s a more efficient access method compared to ref because only one row is expected to match.</li>
<li>e.g. JOIN on gid = gid (1:1)</li>
<li>e.g. <code>SELECT * FROM employees JOIN departments ON employees.department_id = departments.department_id</code>, assuming <code>department_id</code> in <code>departments</code> is a unique indexed column</li>
</ul>
</li>
<li><code>ref_or_null</code>
<ul>
<li>This join type is like the ref type, but MySQL does an extra search for rows that contain <code>NULL</code> values.</li>
</ul>
</li>
<li><code>fulltext</code>
<ul>
<li>A full-text search is performed.</li>
<li>e.g. find the employee name whose name is &lsquo;John&rsquo;</li>
<li>e.g. <code>SELECT * FROM employees WHERE MATCH(employee_name) AGAINST('John')</code>, aassuming <code>employee_name</code> is a column with a <code>FULLTEXT</code> index</li>
</ul>
</li>
<li><code>system</code>
<ul>
<li>This indicates that the query examines a single row from a system table, which contains database-specific metadata.</li>
</ul>
</li>
</ul>
</li>
<li>You generally want <code>ALL</code> or <code>index</code> to be as low as possible.
<ul>
<li>If you see <code>ALL</code>, it means a full table scan is happening which can be a performance hit.</li>
<li>You may need to add an index to speed this up.</li>
</ul>
</li>
</ul>
</li>
<li>possible_keys
<ul>
<li>The indexes that could potentially be used for the query execution.</li>
<li>If <code>possible_keys</code> is <code>NULL</code>, it means there are no relevant indexes that MySQL can use. You might want to add an index.</li>
</ul>
</li>
<li>key
<ul>
<li>The actual key (index) that will be used.</li>
<li>If <code>key</code> is <code>NULL</code>, it means MySQL isn&rsquo;t using an index. This could also indicate the need for an index.</li>
</ul>
</li>
<li>key_len
<ul>
<li>The length of the index used.</li>
<li>Shorter is usually better.</li>
<li>The maximum number of bytes used from the index for key comparisons</li>
<li>It is measured in bytes, and its calculation depends on the data types of the columns involved in the index.</li>
<li>For example, 8 means the length of primary key if it&rsquo;s 8-byte <code>bigint</code></li>
</ul>
</li>
<li>ref
<ul>
<li>It indicates a constant or which column is used against the column present in the <code>key</code> to fetch the data from the table.</li>
<li>Values
<ul>
<li><code>Const</code>
<ul>
<li>the most efficient</li>
<li>If the column value is matched to a constant, you&rsquo;ll see const here. This is an ideal scenario where the query can match exactly one row in the table.</li>
<li>This usually happens when the query is using a primary key or unique index in a WHERE clause.</li>
</ul>
</li>
<li><code>Column Name(s)</code>
<ul>
<li>the named columns are used in an index lookup and are part of the <code>WHERE</code> clause in the query</li>
<li>e.g. <code>SELECT * FROM orders JOIN customers ON orders.customer_id = customers.customer_id</code></li>
<li>e.g. table: <code>orders</code>, type: <code>ref</code>, key: <code>customer_id</code>, ref: <code>customers.customer_id</code></li>
<li>e.g. This indicates that the <code>customer_id</code> column from the <code>customers</code> table is being used in the index <code>customer_id</code> of <code>orders</code> to select rows</li>
</ul>
</li>
<li><code>NULL</code>
<ul>
<li>This shows that no index has been used for this table in the query</li>
<li>can be a sign of less efficient queries as they may indicate full table or index scans</li>
</ul>
</li>
<li><code>func</code>
<ul>
<li>The column is compared to the result of a function.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>rows
<ul>
<li>The rows column indicates the approximately number of rows need to examine to execute the query.</li>
<li>Lower is Better: Generally, you want the number in this column to be as low as possible. The fewer rows that need to be examined, the faster your query will run.</li>
</ul>
</li>
<li>filtered
<ul>
<li>estimates the percentage of table rows that will meet the <code>WHERE</code> condition (before examining any possible JOINs)</li>
<li>If the value is <code>100</code>, it indicates means no filtering of rows occurred</li>
<li>the low number indicates that the query could benefit from an index</li>
<li><code>rows</code> column shows the estimated number of rows examined</li>
<li><code>rows Ã— filtered / 100</code> shows the number of rows that will be joined with the table</li>
<li>For example, rows is 100 and filtered is <code>20.00</code> (20%), which means only around 20 rows will remian after filter has been applied.</li>
</ul>
</li>
<li>Extra
<ul>
<li>Provide additional information about how MySQL resolves the query</li>
<li>Values
<ul>
<li><code>Using index</code>
<ul>
<li>This is generally an ideal value</li>
<li>This indicates a &lsquo;Covering Index Scan&rsquo; â€“ the entire query can be resolved using only information within the index, without having to do additional table lookups.</li>
<li>It suggests that the query can benefit from index optimization.</li>
</ul>
</li>
<li><code>Using where</code>
<ul>
<li>a filtering operation is performed after retrieving rows using an index.</li>
<li>It means that the query needs to evaluate additional conditions that are not covered by the index, and it may involve scanning rows that don&rsquo;t match the conditions.</li>
<li>While <code>using where</code> is not necessarily undesirable, it suggests that additional filtering is performed after retrieving rows using an index.</li>
<li>If this value appears in a significant number of rows in the <code>EXPLAIN</code> output, it may indicate that the query is not fully utilizing the available indexes or that further optimization is possible.</li>
</ul>
</li>
<li><code>Using temporary</code>
<ul>
<li>the query requires the creation of a temporary table to hold intermediate results.</li>
<li>Temporary tables are used when the query involves complex operations or sorting.</li>
<li>This often happens in queries with <code>ORDER BY</code> and <code>GROUP BY</code>.</li>
<li>Using a temporary table is not inherently undesirable, but it indicates that the query requires the creation of a temporary table for sorting or other intermediate results.
<ul>
<li>If this value appears in a significant number of rows or for large result sets, it may suggest potential performance bottlenecks.</li>
</ul>
</li>
</ul>
</li>
<li><code>Using filesort</code>
<ul>
<li>This is generally considered undesirable, because it&rsquo;s less efficient than in-memory sorting or sorting using an index. It may indicate a performance concern.</li>
<li>the query requires a filesort operation to sort the result set. It occurs when the requested order of rows doesn&rsquo;t match the order of the index used, or when sorting cannot be performed using an index.</li>
<li>You might be able to avoid this by indexing the columns in the <code>ORDER BY</code> clause.</li>
</ul>
</li>
<li><code>Using join buffer</code> (<code>Block Nested Loop</code>, <code>Batched Key Access</code>, etc.)
<ul>
<li>This is not necessarily undesirable
<ul>
<li>However, if these values appear frequently and involve large result sets, it may indicate that the query performance could be improved through better indexing or query optimization.</li>
</ul>
</li>
<li>The join is executed by employing a join buffer to hold rows from the table and does not require a full table scan.</li>
<li>The join buffer is a temporary storage area used to process <code>JOIN</code> operations efficiently.</li>
</ul>
</li>
<li><code>Range checked for each record</code>: the query is using a range scan to access rows within a specified range, such as using <code>BETWEEN</code> or <code>IN</code> conditions.</li>
<li><code>Full scan on NULL key</code>: the query is scanning the entire index or table to find rows with NULL values for the indexed column.</li>
<li><code>Distinct</code>: the query is removing duplicate rows from the result set using a distinct operation.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For example</p>
<pre><code>EXPLAIN SELECT * FROM orders WHERE product_id = 123 AND order_date &gt; '2023-01-01';
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | orders | NULL       | ref  | product_index | product_id | 4       | const | 100  |   10.00  | Using where |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-------------+
</code></pre>
<p>In this example, the filtered column shows a value of <code>10.00</code>.
This means MySQL estimates that about <code>10%</code> of the rows selected by the query (specifically, those rows matching the index on <code>product_id</code>) will pass the additional <code>order_date</code> condition in the <code>WHERE</code> clause.
which means there will be only 10 rows in the result.</p>
<h3 id="the-difference-in-the-type-value-between-ref-and-index">The difference in the <code>type</code> value between <code>ref</code> and <code>index</code></h3>
<ul>
<li><code>ref</code>
<ul>
<li>Use an index to look up rows in a table.</li>
<li>It may match multiple rows unlike a unique or primary key (<code>const</code>, <code>eq_ref</code>)</li>
<li>e.g. <code>SELECT * FROM employees WHERE department_id = 10</code>, assuming <code>department_id</code> is an indexed column</li>
</ul>
</li>
<li><code>index</code>
<ul>
<li>Uses the index to do a full index scan</li>
<li>All the data needed is available within the index itself</li>
<li>Usualy the query doesn&rsquo;t have <code>WHERE</code> to help mysql choose an better index</li>
<li>e.g. <code>SELECT department_id FROM employees</code>, assuming <code>department_id</code> is an indexed column</li>
</ul>
</li>
</ul>
<h3 id="what-columns-in-the-explain-output-we-want-to-pay-attention-to">What columns in the <code>EXPLAIN</code> output we want to pay attention to?</h3>
<ul>
<li><code>type</code>: This tells you about how data in the database is scanned</li>
<li><code>possible_keys</code>: This shows which indexes could be used for the query</li>
<li><code>key</code>: This is the actual index that is choen to use for the query</li>
<li><code>rows</code>: This is the estimated number of rows that need to be examined to execute the query</li>
<li><code>Extra</code>: This tells you what else operation needs to be done after filtering out the data</li>
</ul>
<h3 id="whats-filesort">What&rsquo;s <code>filesort</code>?</h3>
<p>The filesort operation is used to sort rows in a result set when the requested order cannot be fulfilled using an index or when sorting cannot be performed in memory.
It involves writing temporary data to disk and performing an external sorting algorithm to order the rows.</p>
<p>Here&rsquo;s what filesort operation does:</p>
<ul>
<li>Sorting Algorithm
<ul>
<li>When a filesort is needed, MySQL uses an external sorting algorithm, typically based on the merge sort algorithm.</li>
<li>This algorithm is designed to efficiently sort data that is too large to fit entirely in memory.</li>
</ul>
</li>
<li>Temporary File
<ul>
<li>MySQL creates a temporary file on disk to store intermediate results during the sorting process.</li>
<li>This file is usually written to the disk, and the data is read back as needed for the sorting operation.</li>
</ul>
</li>
<li>Data Partitioning
<ul>
<li>If the result set is larger than the available memory, MySQL divides the data into partitions that can fit in memory.</li>
<li>It sorts each partition individually and writes the sorted partitions to the temporary file.</li>
</ul>
</li>
<li>Merging Sorted Partitions
<ul>
<li>Once all the partitions are sorted individually, MySQL performs a merge operation to combine the sorted partitions into a single sorted result set.</li>
<li>This merge process continues until all partitions have been merged.</li>
</ul>
</li>
<li>Disk I/O
<ul>
<li>The filesort operation involves reading data from disk, writing intermediate results to disk, and performing disk I/O during the merge process.</li>
<li>This can have an impact on query performance, especially if the disk I/O operations become a bottleneck.</li>
</ul>
</li>
</ul>
<h3 id="how-to-improve-filesort">How to improve <code>filesort</code>?</h3>
<ul>
<li>Ensure that the query is using appropriate indexes</li>
<li>Review the query and the data model to see if there are ways to simplify or optimize the query to reduce the need for filesort</li>
<li>Consider adjusting the MySQL configuration to increase the available memory for sorting operations, if feasible.</li>
<li>Evaluate the possibility of adding or modifying indexes</li>
</ul>
<h1 id="sql-execution-order">SQL Execution order</h1>
<ol>
<li><code>FROM</code></li>
<li><code>JOIN</code></li>
<li><code>ON</code></li>
<li><code>WHERE</code></li>
<li><code>GROUP BY</code></li>
<li><code>HAVING</code></li>
<li><code>SELECT</code></li>
<li><code>ORDER BY</code></li>
<li><code>LIMIT</code></li>
</ol>
<h1 id="independent-subquery-vs-dependent-subquery">Independent Subquery vs Dependent Subquery</h1>
<h3 id="independent-subquery">Independent Subquery</h3>
<p>This type of subquery can be run independently of the outer query. It does not rely on information obtained from the outer query.
It executes once for the entire main query and passes the result set to the main query. Here&rsquo;s an example:</p>
<pre><code>SELECT employee_name
FROM employees
WHERE department_id IN (SELECT department_id FROM departments WHERE location = 'Chicago');
</code></pre>
<p>In this case, the subquery (<code>SELECT ...</code>) can be run independently of the outer query, and it returns a list of department IDs.
This subquery executes once and its result is used by the main query.</p>
<blockquote>
<p>more performance-efficient</p>
</blockquote>
<h3 id="dependent-subquery">Dependent Subquery</h3>
<p>This type of subquery relies on the outer query for its values. This means that the subquery is executed once for each row processed by the outer query. Here&rsquo;s an example:</p>
<pre><code>SELECT e.employee_name
FROM employees e
WHERE EXISTS (SELECT 1 FROM departments d WHERE d.manager_id = e.employee_id AND d.location = 'Chicago');
</code></pre>
<p>In this case, the subquery (<code>SELECT ...</code>) is a dependent subquery because it uses <code>e.employee_id</code> from the outer query.
This subquery executes once for each row in the outer query, checking if an employee is a manager of a department located in &lsquo;Chicago&rsquo;.</p>
<blockquote>
<p>more powerful and flexible because they can use values from the outer query</p>
</blockquote>
<h1 id="tablerow-lock-mysql-56-and-onwards">Table/Row lock (MySQL 5.6 and onwards)</h1>
<blockquote>
<ul>
<li>The table or row lock behaviours depend on the engine such as InnoDB, MyISAM, PostgreSQL. The given list below only serves as a reference or an overview.</li>
<li>As of MySQL 5.6 and onwards, the InnoDB storage engine supports online DDL (Data Definition Language) operations. This allows most types of ALTER TABLE operations to be performed online, meaning that the table remains available for &lsquo;read&rsquo; and &lsquo;write&rsquo; operations during the operation.</li>
</ul>
</blockquote>
<ul>
<li>Table Locks
<ul>
<li><code>TRUNCATE TABLE</code>: This statement removes all rows from a table, and it acquires a table lock to ensure exclusive access during the truncation process.</li>
<li><code>REPAIR TABLE</code>, <code>OPTIMIZE TABLE</code>: Certain table maintenance operations, such as repairing or optimizing a table, may require a table lock to prevent other operations from modifying the table during the maintenance process.</li>
<li><code>LOCK TABLES</code>: This statement explicitly locks one or more tables, preventing other connections from accessing or modifying the locked tables.</li>
<li><code>DDL Statements</code>: Certain data definition language (DDL) statements, like <code>CREATE TABLE</code>, <code>DROP TABLE</code>, or <code>RENAME TABLE</code>, may acquire table locks during their execution.</li>
</ul>
</li>
<li>Row Locks
<ul>
<li><code>UPDATE</code>: When an <code>UPDATE</code> statement modifies one or more rows, it typically acquires row-level locks on the affected rows to ensure data consistency. The locks are held until the transaction is committed or rolled back.</li>
<li><code>DELETE</code>: Similar to the <code>UPDATE</code> statement, a <code>DELETE</code> statement acquires row-level locks on the affected rows to maintain data consistency.</li>
<li><code>SELECT ... FOR UPDATE</code>: When using the <code>SELECT ... FOR UPDATE</code> syntax, the selected rows are locked for exclusive access within the transaction. This allows you to perform updates on the selected rows without conflicts.</li>
<li><code>INSERT INTO ... SELECT</code>: If an <code>INSERT INTO ... SELECT</code> statement inserts data into a table based on a select query, it may acquire row-level locks on the selected rows during the insertion process.</li>
<li><code>Transactions</code>: In a transactional environment, locks can be acquired implicitly during data modification operations to maintain consistency and isolation. The duration and scope of the locks depend on the transaction isolation level and the specific statements executed within the transaction.</li>
</ul>
</li>
<li>No Table or Row lock
<ul>
<li><code>SELECT</code></li>
<li><code>CREATE</code>: such as create a new table, index or view</li>
<li><code>DROP</code>: It doesn&rsquo;t lock on other tables or rows</li>
<li><code>GRAN</code> / <code>REVOKE</code></li>
</ul>
</li>
<li><code>ALTER TABLE</code>
<ul>
<li>At the beginning and end of the operation, brief locks may be required, but for the majority of the operation, normal operations on the table can proceed.
<ul>
<li>Adding a new column.</li>
<li>Adding or dropping an index or primary key.</li>
<li>Changing a column&rsquo;s default value.</li>
<li>Reordering of columns.</li>
<li>Changing the auto_increment value.</li>
<li>Creating, dropping, or renaming a column.</li>
</ul>
</li>
<li>table lock as they require a full table copy
<ul>
<li>Changing the data type of existing columns.</li>
<li>Dropping a column or primary key.</li>
<li>Adding a auto_increment to an existing column.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="add-a-new-column">Add a new column</h3>
<p>Environment: AWS RDS Aurora MySQL 5.6.10a (db.t2.small)</p>
<p>It doesn&rsquo;t lock table.</p>
<p>For 1.3M rows, it takes 67s and the CPU usage is around 35%. It doesn&rsquo;t affect <code>INSERT</code> operation.</p>
<h3 id="modify-a-column-alter-table">Modify a column (ALTER TABLE)</h3>
<p>Environment: AWS RDS Aurora MySQL 5.6.10a (db.t2.small)</p>
<p>This operation locks table as it executes <code>copy to tmp table</code>, so the whole table gets stucked.</p>
<p>It takes 30+ mins for a table with 3M rows.</p>
<p>ref:</p>
<ul>
<li>chatGPT</li>
<li>phind</li>
<li><a href="https://makandracards.com/makandra/10843-mysql-can-i-speed-up-like-queries-by-adding-an-index">https://makandracards.com/makandra/10843-mysql-can-i-speed-up-like-queries-by-adding-an-index</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index">https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index</a></li>
<li><a href="https://www.variables.sh/mysql-explain-plan-examples/">https://www.variables.sh/mysql-explain-plan-examples/</a></li>
<li><a href="https://www.youtube.com/watch?v=BHwzDmr6d7s">https://www.youtube.com/watch?v=BHwzDmr6d7s</a></li>
<li><a href="https://www.youtube.com/watch?v=NKakuDRExJE">https://www.youtube.com/watch?v=NKakuDRExJE</a></li>
</ul>

</article>



</html>
