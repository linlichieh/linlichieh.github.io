<!DOCTYPE html>
<html lang="en-us">
<title>Network | Software engineering notes</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.104.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/index.css">
<link rel="canonical" href="/posts/network/">
<link rel="alternate" type="application/rss+xml" href="" title="Software engineering notes">

<header>
  
    <a href="/" class="title">Software engineering notes</a>
  
  
</header>

<article>
  <header>
    <h1>Network</h1>
    
  </header>
  <h1 id="proxy-server-vs-reverse-proxy-server">Proxy server vs Reverse proxy server</h1>
<h3 id="regular-proxy-server">regular proxy server</h3>
<ul>
<li>When a client sends a request to access a server, the request is first intercepted by the proxy server.</li>
<li>The proxy server then forwards the request to the destination server on behalf of the client, and the server responds to the proxy server.</li>
<li>The proxy server then forwards the response back to the client.</li>
</ul>
<p>flow</p>
<pre><code>client -&gt; proxy server -&gt; server
</code></pre>
<p>For example: CDN and Nginx</p>
<h3 id="reverse-proxy-server">reverse proxy server</h3>
<ul>
<li>When a client sends a request to access a server, the request is first intercepted by the reverse proxy server.</li>
<li>The reverse proxy server then forwards the request to one of the servers in the group on behalf of the client, and that server responds to the reverse proxy server.</li>
<li>The reverse proxy server then forwards the response back to the client.</li>
</ul>
<p>flow</p>
<pre><code>client -&gt; reverse proxy server
                    |--------------&gt; server A
                    |--------------&gt; server B
                    |--------------&gt; server C
</code></pre>
<p>For example:  Load balancer</p>
<h3 id="the-difference-between-regular-proxy-server-and-reverse-proxy-server">The difference between regular proxy server and reverse proxy server</h3>
<p>reverse proxy server needs a set of rules for forwarding requests to the destination server
while regular proxy server simply forwards the request without any specific rules</p>
<h1 id="p2p-connection">P2P connection</h1>
<h3 id="introduction">Introduction</h3>
<p>When two servers behind their own NATs need to establish a P2P connection,
they need to exchange information about their private IP and port numbers to establish a direct connection.
This process is called NAT traversal.</p>
<h3 id="techniques-for-nat-traversal">Techniques for NAT Traversal</h3>
<ul>
<li>STUN (Session Traversal Utilities for NAT)
<ul>
<li>To allow a server to know its own public IP and port</li>
</ul>
</li>
<li>TURN (Traversal Using Relays around NAT)
<ul>
<li>A relay server to allows the servers to communicate even if they are behind different types of NATs</li>
</ul>
</li>
<li>ICE (Interactive Connectivity Establishment).
<ul>
<li>A combination of STUN and TURN to support both approaches to communicate. STUN is the priority if works.</li>
</ul>
</li>
</ul>
<h3 id="the-steps-to-establish-a-p2p-connection-between-2-servers-behind-their-own-nats">The steps to establish a p2p connection between 2 servers behind their own NATs</h3>
<p>The first server sends a connection request to the second server. The connection request includes the first server&rsquo;s private IP and port as well as the public IP and port of the NAT device that the first server is behind.
The second server receives the connection request from the first server, but because it is behind a NAT device, the request appears to come from the public IP and port of the NAT device and not the private IP and port of the first server.</p>
<pre><code>                                SDP offer
First Server (FS)   ─────&gt;&gt;&gt;───[Connection Request]───────&gt;&gt;&gt;   Second Server (SS)
                               Private IP &amp; Port (FS)
                               Public IP &amp; Port (NAT FS)
</code></pre>
<p>The second server sends a response back to the first server. This response includes the second server&rsquo;s private IP and port as well as the public IP and port of the NAT device that the second server is behind.
The first server receives the response from the second server, but because it is behind a NAT device, the response appears to come from the public IP and port of the NAT device and not the private IP and port of the second server.</p>
<pre><code>                                    SDP answer
First Server (FS)   &lt;&lt;&lt;─────────────[Response]──────&lt;&lt;&lt;──────   Second Server (SS)
                                  Private IP &amp; Port (SS)
                                  Public IP &amp; Port (NAT SS)
</code></pre>
<p>The first server sends a second connection request to the second server. This request includes the private IP and port of the first server and the public IP and port of the NAT device that the first server is behind, as well as the private IP and port of the second server and the public IP and port of the NAT device that the second server is behind.</p>
<pre><code>First Server (FS)   ───&gt;&gt;&gt;───[2nd Connection Request]─────&gt;&gt;&gt;   Second Server (SS)
                                  Private IP &amp; Port (FS)
                                  Public IP &amp; Port (NAT FS)
                                  Private IP &amp; Port (SS)
                                  Public IP &amp; Port (NAT SS)
</code></pre>
<p>The second server receives the second connection request from the first server, and because it now has both private and public IP and port information for both servers, it is able to create a mapping in its NAT device that allows incoming traffic from the first server to be routed to the second server.</p>
<pre><code>First Server (FS)   ───&gt; NAT ────[2nd Connection Request]───&gt; NAT ───&gt; Second Server (SS)
                          ├─ Private IP &amp; Port (FS)            ├─ Private IP &amp; Port (FS)
                          ├─ Public IP &amp; Port (NAT FS)         ├─ Public IP &amp; Port (NAT FS)
                          ├─ Private IP &amp; Port (SS)            ├─ Private IP &amp; Port (SS)
                          └─ Public IP &amp; Port (NAT SS)         └─ Public IP &amp; Port (NAT SS)
</code></pre>
<p>The two servers are now able to establish a P2P connection and communicate directly with each other.</p>
<pre><code>First Server (FS)    &lt;────────────[P2P Connection]──────────&gt;   Second Server (SS)
</code></pre>
<h1 id="osi-model">OSI Model</h1>
<h3 id="standard-osi-model">Standard OSI model</h3>
<ol>
<li>Physical
<ul>
<li>electric signals / driver</li>
</ul>
</li>
<li>Data Link
<ul>
<li>frames / mac address / ethernet</li>
</ul>
</li>
<li>Network
<ul>
<li>IP / ARP / ICMP</li>
<li>destination and source IP</li>
</ul>
</li>
<li>Transport
<ul>
<li>TCP / UDP</li>
<li>destination and source Port to identify services or applications</li>
</ul>
</li>
<li>Session
<ul>
<li>connection establishment / TLS</li>
<li>state / stateful / cookie session</li>
</ul>
</li>
<li>Presentation
<ul>
<li>encoding / serialisation</li>
<li>JSON object / UTF-8</li>
</ul>
</li>
<li>Application
<ul>
<li>HTTP / FTP / gRPC</li>
</ul>
</li>
</ol>
<p>it can be simplified like this</p>
<ol>
<li>Physical
<ul>
<li>Bits -&gt; Signal</li>
</ul>
</li>
<li>Data Link
<ul>
<li>Frame</li>
</ul>
</li>
<li>Network
<ul>
<li>Packet (OS makes the segment into packet using IP protocal)</li>
</ul>
</li>
<li>Transport
<ul>
<li>Segment (break the data into small pieces)</li>
</ul>
</li>
<li>Application (Session + Presentation + Application)
<ul>
<li>Protocol Data Unit / Data <code>100110100110...</code></li>
</ul>
</li>
</ol>
<p>TCP/IP model</p>
<ol>
<li>Network Access (Data Link + Pyhsical)</li>
<li>Internetwork (Network)</li>
<li>Transport (Transport)</li>
<li>Application (Session + Presentation + Application)</li>
</ol>
<h3 id="an-example-to-explain-how-osi-model-deal-with-sending-a-post-request-to-https-endpoint">An example to explain how OSI model deal with sending a POST request to HTTPs endpoint</h3>
<ul>
<li>Application
<ul>
<li>This is where the HTTP protocol lives.</li>
<li>A POST request is formed here with all necessary elements including the request method (POST), headers, and the message body.</li>
</ul>
</li>
<li>Presentation
<ul>
<li>This layer is responsible for data representation and encryption.</li>
<li>In the case of HTTPS, the data is encrypted for security. This is also where data compression could occur if needed.</li>
</ul>
</li>
<li>Session
<ul>
<li>This layer establishes, manages, and terminates connections between applications.</li>
<li>In this context, it would be maintaining the connection for the HTTPS session.</li>
</ul>
</li>
<li>Transport
<ul>
<li>This layer is responsible for end-to-end communication services for applications.</li>
<li>In the case of HTTPS, it typically uses TCP (Transmission Control Protocol) to ensure that packets are sent and received in the correct order.</li>
<li>This is also where services like error checking and data recovery occur.</li>
</ul>
</li>
<li>Network
<ul>
<li>This layer is responsible for packet forwarding, including routing through different networks.</li>
<li>The IP (Internet Protocol) address of the HTTPS endpoint would be used here to route the request to the correct location.</li>
</ul>
</li>
<li>Data Link
<ul>
<li>This layer provides reliable transit of data across a physical or logical link.</li>
<li>It&rsquo;s involved in error detection and correction, as well as defining the protocol for the next layer to use.</li>
</ul>
</li>
<li>Physical
<ul>
<li>This is the lowest layer of the OSI model, and it&rsquo;s responsible for the actual physical connection between the devices.</li>
<li>It defines the characteristics of the hardware to be used for the transmission like the cables, connectors, and the binary transmission of data.</li>
</ul>
</li>
</ul>
<p>Ref: gpt-4</p>
<h1 id="ip">IP</h1>
<h3 id="basics">Basics</h3>
<ul>
<li><code>192.168.1.14</code>
<ul>
<li><code>192.168.1</code>: class of network</li>
<li><code>.14</code>: assigned to each host; an unique identified machine</li>
</ul>
</li>
<li>broadcast address: host ID is filled with 1</li>
</ul>
<h3 id="subnet-mask">Subnet mask</h3>
<ul>
<li>IP <code>192.168.123.132</code> / <code>255.255.255.0/24</code>
<ul>
<li>ip address: <code>192.168.123.132</code></li>
<li>subnet mask: <code>255.255.255.0</code></li>
<li>network address: <code>192.168.123.0</code></li>
<li>Usable Host IP Range: <code>1.163.70.205</code> - <code>1.163.70.206</code></li>
</ul>
</li>
<li>IP <code>1.163.70.205</code> /  <code>255.255.255.252/30</code>
<ul>
<li>ip address: <code>1.163.70.205</code></li>
<li>subnet mask: <code>255.255.255.252</code></li>
<li>network address: <code>192.168.123.204</code></li>
<li>Broadcast Address: <code>192.168.123.207</code></li>
<li>Usable Host IP Range: <code>1.163.70.205</code> - <code>1.163.70.206</code></li>
<li>last part of address
<ul>
<li>11001100 204</li>
<li>11001101 205</li>
<li>11001110 206</li>
<li>11001111 207</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="classes">Classes</h3>
<ul>
<li>Class A
<ul>
<li>0</li>
<li><code>0.0.0.0</code> - <code>127.255.255.255</code></li>
<li>private ip (<code>10.0.0.0/8</code>): <code>10.0.0.0</code> - <code>10.255.255.255</code></li>
</ul>
</li>
<li>Class B
<ul>
<li>10</li>
<li><code>128.0.0.0</code> - <code>191.255.255.255</code></li>
<li>private ip (<code>172.16.0.0/12</code>): <code>172.16.0.0</code> – <code>172.31.255.255</code></li>
</ul>
</li>
<li>Class C
<ul>
<li>110</li>
<li><code>192.0.0.0</code> - <code>223.255.255.255</code></li>
<li>private ip (<code>192.168.0.0/16</code>): <code>192.168.0.0</code> – <code>192.168.255.255</code></li>
</ul>
</li>
<li>Class D
<ul>
<li>1110</li>
<li><code>224.0.0.0</code> - <code>239.255.255.255</code></li>
</ul>
</li>
<li>Class E
<ul>
<li>11110</li>
<li><code>240.0.0.0</code> - <code>247.255.255.255</code></li>
</ul>
</li>
</ul>
<h3 id="special-ip-address-ranges-that-are-used-for-special-purposes-are">Special IP address ranges that are used for special purposes are:</h3>
<ul>
<li><code>0.0.0.0</code>: addresses used to communicate with the local network</li>
<li><code>127.0.0.0</code>: loopback addresses</li>
<li><code>255.255.255.255</code>: a limited broadcast address, which is used to send a network broadcast packet to all devices on the local network</li>
</ul>
<h1 id="load-balance">Load Balance</h1>
<p>分幾種, 常見的是 L3, L7</p>
<p>L3 是 IP 層, 是以指派 IP 到後面的主機</p>
<p>L7 是 HTTP 層, 分析 Domain 或 Header 再指派到後面的主機, 效率較 L3 快</p>
<h1 id="長連線">長連線</h1>
<p>飽活封包底層就會做掉了, 建 socket 就會傳心跳 (habit) 給 server 確認它活著</p>
<p>habit 是 tcp 三項交握的 sync 封包</p>
<h1 id="tcp">TCP</h1>
<h3 id="3-way-handshake">3-way handshake</h3>
<ul>
<li>SYN: The client sends a packet with the SYN (synchronize) flag set to the server.</li>
<li>SYN-ACK: The server acknowledges the client&rsquo;s SYN packet by sending a packet with both the SYN and ACK (acknowledge) flags set.</li>
<li>ACK: The client acknowledges the server&rsquo;s SYN-ACK packet by sending a packet with the ACK flag set.</li>
</ul>
<p>diagram</p>
<pre><code>Client                                                                Server
  |                                                                     |
  |----- SYN (Sequence Number: X) -------------------------------------&gt;|
  |                                                                     |
  |&lt;---- SYN-ACK (Sequence Number: Y, Acknowledgment Number: X + 1) ----|
  |                                                                     |
  |----- ACK (Acknowledgment Number: Y + 1) ---------------------------&gt;|
  |                                                                     |
</code></pre>
<h3 id="tcp-states">TCP states</h3>
<ul>
<li>CLOSED: No connection is active or pending.</li>
<li>LISTEN: The server is waiting for an incoming call. This state signifies that a socket is ready to accept incoming connections.</li>
<li>SYN-SENT: The application has started to open a connection and the system has sent a SYN message to start the three-way handshake. This state signifies that the client has sent a connection request and is waiting for the SYN-ACK reply.</li>
<li>SYN-RECEIVED: The server just received a SYN request from a client and has responded with SYN-ACK. It is now waiting for an ACK from the client.</li>
<li>ESTABLISHED: The connection is active, and both devices can send and receive data. The system has received an acknowledgment of the connection.</li>
<li>FIN-WAIT-1: The application has said it is finished with the connection. This state indicates that the system is waiting for the remote side of the connection to send its own FIN signal.</li>
<li>FIN-WAIT-2: The system is waiting for the other side to terminate its half of the connection. This follows the receipt of the first FIN signal.</li>
<li>CLOSE-WAIT: The remote side has shut down, and the system is waiting for the application to close its own side of the connection.</li>
<li>CLOSING: Both sides have sent but not yet acknowledged the FIN signals.</li>
<li>LAST-ACK: The system is in the process of terminating the connection and is waiting for a final acknowledgment.</li>
<li>TIME-WAIT: The connection has been closed, and the system is waiting to be sure that the remote system received the last acknowledgment.</li>
</ul>
<h3 id="time_wait">TIME_WAIT</h3>
<p>When a connection is closed, it will be turned into the state TIME_WAIT. Network in real world can be unpredicable.
There is no gurantee for packet to be delivered in order. When lost packet was delayed to ask to close the connection,
which was already disconnected, server might be confused by it and close the new established connection if it doesn&rsquo;t
have TIME_WAIT state. TIME_WAIT keeps the info of source address, source port, destination address and destination port.
When server recevied delayed packet to ask for closing connection, server can use TIME_WAIT to verify whether it has
been closed or not. TIME_WAIT&rsquo;s purpose is for preventing server from messing up the new connection from the same address.</p>
<p>When you close the socket&rsquo;s file descriptor, the file descriptor itself is closed, but the socket in TIME_WAIT will still consume file descriptors.
Therefore, a socket in TIME_WAIT consumes file descriptors</p>
<h3 id="查看系統-tcp-相關設定">查看系統 TCP 相關設定</h3>
<p>MacOS:</p>
<pre><code>sysctl net.inet.tcp
</code></pre>
<h3 id="tcp-timeout">TCP timeout</h3>
<p>OS 預設會對 connection 設 timeout, 如果這段期間 connection 是閒置的(沒有 write, read, heartbeat), connection 就會被切斷</p>
<h3 id="keep-alive">keep alive</h3>
<p>發送心跳包, 用來偵測連線是否還正常, server/client 都可以設定, 可以自已調整心跳的頻率,
它的功能只有探測而且只有在 write/read 沒有在發送的時候才會去發送心跳包</p>
<h3 id="斷線發生的情況">斷線發生的情況</h3>
<ol>
<li>程式自已下 conn.Close by server or client</li>
<li>心跳包發現對方沒回應</li>
<li>使用中 read/write 超過 timeout</li>
</ol>
<h3 id="加速">加速</h3>
<p>google TCP BBR</p>
<h3 id="simultaneously-maximum-connection-for-a-server">simultaneously maximum connection for a server</h3>
<p>ref: <a href="https://www.quora.com/What-is-the-maximum-number-of-concurrent-tcp-connections-system-can-support">https://www.quora.com/What-is-the-maximum-number-of-concurrent-tcp-connections-system-can-support</a></p>
<pre><code>The theoretical maximum number of connections per client per server port is 65534.
Assuming one network interface (i.e., 1 IP on your host),
then you could potentially make ~4 million (IP address space size) x 65534.
I think maybe we should talk in logarithmic terms since this number is already so huge :)
What will bite you before that will be other issues - such as the design of application which is making or handling such connections,
your OS's TCP/IP stack design or ultimately the amount of memory.
If memory is not the issue and you want to increase that number,
you can add another network interface and double this number further (ie., increase number of clients).
</code></pre>
<p>ref: <a href="https://medium.com/fantageek/understanding-socket-and-port-in-tcp-2213dc2e9b0c">https://medium.com/fantageek/understanding-socket-and-port-in-tcp-2213dc2e9b0c</a></p>
<pre><code>What is the maximum number of concurrent TCP connections that a server can handle, in theory ?

A single listening port can accept more than one connection simultaneously.
There is a ‘64K’ limit that is often cited, but that is per client per server port, and needs clarifying.
If a client has many connections to the same port on the same destination,
then three of those fields will be the same — only source_port varies to differentiate the different connections.
Ports are 16-bit numbers, therefore the maximum number of connections any given client can have to any given host port is 64K.
However, multiple clients can each have up to 64K connections to some server’s port,
and if the server has multiple ports or either is multi-homed then you can multiply that further
So the real limit is file descriptors. Each individual socket connection is given a file descriptor,
so the limit is really the number of file descriptors that the system has been configured to allow and resources to handle.
The maximum limit is typically up over 300K, but is configurable e.g. with sysctl
</code></pre>
<h3 id="nf_conntrack-table-full-dropping-packet">nf_conntrack: table full, dropping packet</h3>
<h5 id="whats-nf_conntract">What&rsquo;s nf_conntract?</h5>
<p>It is a feature to allow kernel to keep track of connections. It might be only used in haproxy server.
When NAT or firewall works, it&rsquo;s nf_conntrack under the hood. nf_conntract records connections info,
including the mapping between public IPs (external IPs) and private IPs (internal IPs) for NAT,
so that the packets can be sent to the right end.</p>
<h5 id="what-are-common-causes">What are common causes?</h5>
<ul>
<li>High volume of connections: If your system is handling a high volume of concurrent connections, the nf_conntrack table might become full. This can happen in cases where your system is serving as a heavily utilized NAT device, firewall, or high-traffic web server.</li>
<li>Many short-lived connections: A large number of short-lived connections (e.g., connections that are opened and closed quickly) can cause the nf_conntrack table to fill up, especially if the connection tracking entries are not being cleared quickly enough.</li>
<li>Inadequate connection timeouts: The nf_conntrack subsystem relies on connection timeouts to determine when to remove connection entries from the table. If the connection timeouts are set too high, the entries will remain in the table longer, which can cause the table to become full.</li>
<li>Connection tracking table size: The maximum size of the nf_conntrack table is determined by the nf_conntrack_max parameter. If this parameter is set too low for your system&rsquo;s requirements, the table may fill up quickly.</li>
<li>DDoS or flood attacks: Your system might be experiencing a Distributed Denial of Service (DDoS) attack or a SYN flood attack, causing a massive influx of connections that fill up the nf_conntrack table.</li>
</ul>
<h5 id="how-to-solve-this">How to solve this?</h5>
<p>Note: If it is full, it won&rsquo;t accept new connection. There are 3 ways to fix it:</p>
<ul>
<li>Disable connection track (recommend)</li>
<li>Reduce the timeout of connection being tracked</li>
<li>Increase the maximum of connection tracking table</li>
</ul>
<h5 id="if-nf_conntrack-is-disabled-what-would-be-the-impact">If nf_conntrack is disabled, what would be the impact?</h5>
<ul>
<li>NAT functionality impairment: Connection tracking plays a crucial role in NAT, which is responsible for translating between private IP addresses and public IP addresses. Disabling nf_conntrack would impair NAT functionality, causing issues with IP address translations and breaking communication between internal and external networks.</li>
<li>Firewall rule impact: If your firewall rules (iptables) are based on connection state (e.g., NEW, ESTABLISHED, RELATED), disabling nf_conntrack would cause those rules to fail. This could result in unexpected behavior in your firewall, potentially making it more permissive or more restrictive.</li>
<li>Performance impact: In some cases, disabling connection tracking might improve system performance if your device is dealing with a very high number of connections and connection tracking is causing resource exhaustion. However, it could also lead to performance issues if your system relies on connection tracking for stateful packet filtering, NAT, or other functions that require maintaining state information.</li>
</ul>
<h1 id="tls-https">TLS (HTTPS)</h1>
<h3 id="tls">TLS</h3>
<ul>
<li>All transitted  data is encrypted with SSL/TLS protocols</li>
<li>Ensures that the client is not communicating with a fake or malicious server.</li>
</ul>
<h3 id="what-are-the-steps-to-apply-tls-for-your-domain">What are the steps to apply TLS for your domain?</h3>
<ol>
<li>Generate a private-public key pair
<ul>
<li>The public key will be shared as part of the digital certificate</li>
</ul>
</li>
<li>Create a Certificate Signing Request (CSR).
<ul>
<li>CSR content
<ul>
<li>include public key, domain, and other details</li>
<li>they aren&rsquo;t encrypted by private key</li>
</ul>
</li>
<li>Generate a unique signature
<ul>
<li>Generate a hash of the CSR content using a cryptographic hash function</li>
<li>Sign the hash using the private key</li>
</ul>
</li>
<li>Create the CSR file
<ul>
<li>Encode the CSR content and signature using base64</li>
<li>Create a CSR file by wrapping Base64-encoded text with header and footer lines.</li>
<li>CSR is typically in Privacy-Enhanced Mail (PEM) format.</li>
<li>Command to generate CSR file <code>openssl req -new -key private_key.pem -out my_csr.pem</code></li>
</ul>
</li>
<li>Signature is the only data to be encrypted by private key. Public key and domain aren&rsquo;t.</li>
</ul>
</li>
<li>Submit CSR to a Certificate Authority (CA)</li>
<li>CA verifies your CSR file for Domain and organization validation
<ul>
<li>The CA extracts the Base64-encoded content of the CSR (between header and footer)</li>
<li>Convert it back into binary data that contains the actual CSR information in a standardized format, such as PKCS#10 or X.509.</li>
<li>The CA parses the binary data to extract the public key, domain, signature and other information.</li>
<li>The CA can just read public key and domain without needing your private key.</li>
<li>The CA uses the included public key to verify the signature of the CSR.</li>
<li>This step ensures that the CSR was indeed created using the corresponding private key and that the data within the CSR has not been tampered with.</li>
<li>Since public-private key pairs are mathematically linked, the CA can perform this verification without access to your private key.</li>
</ul>
</li>
<li>Get a digital certificate from CA
<ul>
<li>Once CA successfully verifies your CSR, it will issue you a digital certificate.</li>
<li>the certificate file(s) in a format like PEM or PFX/PKCS#12 includes:
<ul>
<li>Your server certificate: for your domain, containing the public key and other verified information</li>
<li>Intermediate certificates: to maintain security and limit the risk associated with the compromise of a root certificate</li>
<li>Root certificate (optional): Some CAs might provide their root certificate, but it&rsquo;s often unnecessary, as most web servers and clients already have trusted root certificates pre-installed</li>
</ul>
</li>
</ul>
</li>
<li>Install the digital certificate
<ul>
<li>Install the server certificate
<ul>
<li>Save the server certificate, private key, and (if provided) intermediate certificate(s) to a secure location on your server.</li>
</ul>
</li>
<li>Install intermediate certificates (if provided)
<ul>
<li>Concatenate the intermediate certificate(s) to the end of your server certificate file. <code>cat server.crt intermediate.crt &gt; combined.crt</code></li>
</ul>
</li>
</ul>
</li>
<li>Configure the web server
<ul>
<li>Taking Nginx as an example
<ul>
<li><code>listen 443 ssl;</code></li>
<li><code>ssl_certificate_key /path/to/private.key</code></li>
<li><code>ssl_certificate /path/to/combined.crt</code></li>
<li><code>ssl_protocols TLSv1.2 TLSv1.3;</code></li>
<li><code>ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-CHACHA20-POLY1305';</code></li>
<li><code>ssl_prefer_server_ciphers on;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>CSR file looks like below</p>
<pre><code>-----BEGIN CERTIFICATE REQUEST-----
MIIC2jCCAcICAQAwgZExCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTESMBAGA1UE
BwwJU2FuIEpvc2UxEDAOBgNVBAoMB0FDTUUgSW5jMRQwEgYDVQQLDAtFbmdpbmVl
cmluZzEUMBIGA1UEAwwLZXhhbXBsZS5jb20xHDAaBgkqhkiG9w0BCQEWDXN1cHBv
cnRAZXhhbXBsZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDU
...
I+9M5Q5cej5qY7lJlgvKx6kLca6fDDU6B5CJGOyTeX9gToh1JUX8W+RJvRZlQ2Fw
-----END CERTIFICATE REQUEST-----
</code></pre>
<h3 id="how-https-works">How HTTPS works?</h3>
<ol>
<li>DNS resolution: the browser first performs a DNS lookup to find the IP address associated with the domain name.</li>
<li>TCP handshake: The browser establishes a TCP connection with the web server at the IP address obtained during DNS resolution.</li>
<li>SSL/TLS handshake: Once the TCP connection is established, the browser initiates the SSL/TLS handshake to securely exchange cryptographic parameters and establish a secure connection.
<ol>
<li>ClientHello: The client initiates the handshake by sending a ClientHello message, which includes the supported TLS protocol versions, a list of cipher suites, a ClientRandom number, and any additional extensions (such as SNI).</li>
<li>ServerHello: The server responds with a ServerHello message containing the selected TLS protocol version, the chosen cipher suite, and a ServerRandom number.</li>
<li>Server Certificate: The server sends its digital certificate containing its public key and identity information to the client. This allows the client to authenticate the server and encrypt the data exchanged during the handshake.</li>
<li>ServerHelloDone: The server sends a ServerHelloDone message to signal the end of its part of the handshake negotiation.</li>
<li>ClientKeyExchange: The client generates a PreMasterSecret, encrypts it with the server&rsquo;s public key (from the server&rsquo;s certificate), and sends the encrypted PreMasterSecret in a ClientKeyExchange message.
<ul>
<li>PreMasterSecret, which is a random value that both the client and server will use to compute a shared secret called the Master Secret.</li>
<li>This ensures that only the server can decrypt the PreMasterSecret, as it possesses the corresponding private key.</li>
<li>The server receives the ClientKeyExchange message and decrypts the PreMasterSecret using its private key.</li>
</ul>
</li>
<li>ChangeCipherSpec: Both the client and server send a ChangeCipherSpec message to indicate that subsequent messages will be encrypted using the negotiated cipher suite and keys derived from the PreMasterSecret, ClientRandom, and ServerRandom.</li>
<li>Finished: Both the client and server send an encrypted Finished message containing a hash of the complete handshake process to verify its integrity.</li>
</ol>
</li>
<li>Secure data exchange: After the SSL/TLS handshake is complete, the client and server can exchange application data over the encrypted SSL/TLS connection. All messages are encrypted and decrypted using symmetric encryption keys derived from the PreMasterSecret and the ClientRandom and ServerRandom values.
<ul>
<li>Both the client and server now have the same PreMasterSecret.</li>
<li>The Master Secret is then used to derive symmetric encryption keys, also known as session keys, for data encryption and integrity checks.</li>
</ul>
</li>
<li>Connection closure: When the client and server have finished exchanging data, they send close_notify alerts to each other to signal the end of the secure connection. The underlying TCP connection is then closed through the standard TCP connection termination process.</li>
</ol>
<p>The SSL/TLS handshake process:</p>
<pre><code>Client                                                                                    Server
  |                                                                                         |
  | ----------- ClientHello (Supported versions, cipher suites, ClientRandom) ------------&gt; |
  |                                                                                         |
  | &lt;---------- ServerHello (Selected version, cipher suite, ServerRandom) ---------------- |
  | &lt;---------- Server Certificate (Server's public key, identity information) ------------ |
  | &lt;---------- ServerHelloDone ----------------------------------------------------------- |
  |                                                                                         |
  | ----------- ClientKeyExchange (Encrypted PreMasterSecret with server's public key) ---&gt; |
  | ----------- ChangeCipherSpec (Switch to negotiated cipher) ---------------------------&gt; |
  | ----------- Finished (Encrypted handshake hash) --------------------------------------&gt; |
  |                                                                                         |
  | &lt;---------- ChangeCipherSpec (Switch to negotiated cipher) ---------------------------- |
  | &lt;---------- Finished (Encrypted handshake hash) --------------------------------------- |
  |                                                                                         |
  | &lt;---------- (Encrypted data exchange using negotiated cipher suite) ------------------&gt; |
</code></pre>
<h3 id="keep-alive-1">Keep-alive</h3>
<p>tcp 沒有 keep-alive 一個 request 就會佔用一條通道</p>
<p>tcp 有 keep-alive 就多個 request 只需做一次三項交握, 都在同一條通道傳送</p>
<p>一個 socket 只能接一個 session, 不能一對多</p>
<h3 id="https-header-加密範圍">HTTPS header 加密範圍</h3>
<p>SSL 憑證加密, 從 Header 到 Body 都是加密的</p>
<h3 id="put-與-patch-差異">PUT 與 PATCH 差異</h3>
<p>PUT 相當於是 delete + insert, 是對整個資源進行更新</p>
<p>PATCH 是只更新部份的資源</p>
<h3 id="瀏覽器支援-patch-put-跟-delete-嗎">瀏覽器支援 PATCH, PUT 跟 DELETE 嗎?</h3>
<p><strong>不支援</strong></p>
<p>HTML 只定義了 GET/POST,</p>
<p>所以 HTML Form 是沒有支援 PUT/DELETE 的</p>
<p>但 XmlHttpRequest (也就是Ajax) 有定義 GET/POST/PUT/PATCH/DELETE/HEAD/OPTIONS</p>
<p><strong>但可以在 HTML Form 裡偷藏 _method 參數, 定義不支援的 method</strong>, 送到 server 端再判斷</p>
<h3 id="etag">Etag</h3>
<p>第一次 : browser 對 server 發出請求, server 回應 200 ok, 並多加上 header[&lsquo;ETag&rsquo;] =  body 以 md5 編碼</p>
<p>browser 會 cache response 及儲存 Etag</p>
<p>第二次 : browser 對 server 發出請求並多帶 headers[&lsquo;If-None-match&rsquo;] = 上面 ETag 的值, server 再算出 ETag 是否值為一樣, 一樣的話會返回 304 Not Modified</p>
<p>browser 收到 304 會從 cache 拿之前 cache 的結果</p>
<h3 id="terms-of-url">Terms of URL</h3>
<p><code>http://example.com/public/index.html#post</code></p>
<ul>
<li>URL (Uniform Resource Locator): <code>http://example.com/public/index.html</code></li>
<li>URN (Uniform Resource Name): <code>example.com/public/index.html#post</code></li>
<li>URI (Uniform Resource Identifier): <code>http://example.com/public/index.html#post</code></li>
</ul>
<p><code>http://www.example.com:8888/public/index.html?key=value#hashtag</code></p>
<ul>
<li>Scheme / Protocol: <code>http</code></li>
<li>Host: <code>www.example.com:8888</code></li>
<li>Hostname / Domain: <code>example.com</code></li>
<li>Subdomain / Third level domain: <code>www</code></li>
<li>Port: <code>8888</code></li>
<li>Path: <code>/public</code></li>
<li>Query: <code>key=value</code></li>
<li>Frament / Hash: <code>#hashtag</code></li>
</ul>
<h3 id="restful-apis">Restful APIs</h3>
<pre><code>Index       GET     /users
Show        GET     /users/1
New         GET     /users/new
Create      POST    /users
Edit        GET     /users/1/edit
Update      PUT     /users/1
Detele      DELETE  /users/1
</code></pre>
<h3 id="get">GET</h3>
<p>GET 是我們最常使用也是最簡單的，它帶資料的方式就是把 query string 放在網址後面 :</p>
<pre><code>example.com?f1=v1&amp;f2=v2
</code></pre>
<p>GET 沒有 Body, 整個 Http 封包會像這樣 :</p>
<pre><code>GET /api/test?f1=v1&amp;amp;f2=v2 HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Cache-Control: no-cache
Postman-Token: 0f99b8e9-0322-952e-a67c-76b498c51903
</code></pre>
<h3 id="post-form">POST form</h3>
<p>當要背景傳送資料時要使用 POST，也就是我們常在用的表單，它的實現原理是在 Header 加上 <code>Content-Type: application/x-www-form-urlencoded</code></p>
<p>而 Body 就是 query string :</p>
<pre><code>f1=v1&amp;f2=v2
</code></pre>
<p>整個 Http 封包會像這樣 :</p>
<pre><code>POST /api/test?f1=f1&amp;amp;f2=v2 HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Cache-Control: no-cache
Postman-Token: 3f036f1b-dfec-1269-41b7-bbf6781cbac4

f1=v1&amp;f2=v2
</code></pre>
<blockquote>
<p>POST 可同時支援 GET 及 POST 的參數</p>
</blockquote>
<h3 id="post-with-file">POST with file</h3>
<p>如果要傳送檔案，就不是用原本的 <code>Content-Type: application/x-www-form-urlencoded</code>，要改用 <code>Content-Type: multipart/form-data</code></p>
<p>雖然說 Content-Type 使用後者，但仍然一樣可以傳送 form data</p>
<p>你的 params 會被拆解成一塊一塊的，整個 Http 封包會像這樣 :</p>
<pre><code>POST /api/test/ HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
Cache-Control: no-cache
Postman-Token: b953aac1-b8d5-f1e4-36ac-2672b3a028fc

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;&quot;
Content-Type:

data:application/octet-stream;base64,/9j/4AAQSkZJRgABAQEASABIAA....
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;f1&quot;

v1
------WebKitFormBoundary7MA4YWxkTrZu0gW--
</code></pre>
<h1 id="different-encryption-techniques">Different Encryption Techniques</h1>
<ul>
<li>SSH and SSL use Symmetrical encryption and Asymmetrical encryption.</li>
<li>SSH
<ul>
<li>Symmetrical encryption is used to encrypt the entire communication during a SSH Session.</li>
<li>Asymmetrical encryption is not used to encrypt the entire SSH session. Instead, it is only used during the key exchange algorithm of symmetric encryption.</li>
<li>Before initiating a secured connection, both parties generate temporary public-private key pairs, and share their respective private keys to produce the shared secret key.</li>
</ul>
</li>
</ul>
<h3 id="symmetrical-encryption">Symmetrical encryption</h3>
<ul>
<li>Symmetric encryption is a form of encryption where a secret key is used for both encryption and decryption of a message by both the client and the host.</li>
<li>Both the client and the server derive the secret key using an agreed method, and the resultant key is never disclosed to any third party.</li>
<li>AES(Advanced Encryption Standard): AES-128, AES-192, and AES-256</li>
<li>Plain Text &ndash;Encryption(same secret key)&ndash;&gt; Cipher Text &ndash;Decryption(same secret key)&ndash;&gt; Plain Text</li>
</ul>
<h3 id="asymmetrical-encryption">Asymmetrical encryption</h3>
<ul>
<li>Unlike symmetrical encryption, asymmetrical encryption uses two separate keys for encryption and decryption.</li>
<li>These two keys are known as the public key and the private key.</li>
<li>A message that is encrypted by a machine’s public key, can only be decrypted by the same machine’s private key.</li>
<li>This one-way relation means that the public key cannot decrypt its own messages, nor can it decrypt anything encrypted by the private key.</li>
<li>A message that is encrypted using a public key can only be decrypted using a private key, while also, a message encrypted using a private key can be decrypted using a public key.</li>
<li>EIGamal, RSA, DSA, Elliptic curve techniques, PKCS</li>
<li>Plain Text &ndash;Encryption(public key)&ndash;&gt; Cipher Text &ndash;Decryption(private Key)&ndash;&gt; Plain Text</li>
<li>Plain Text &ndash;Encryption(private key)&ndash;&gt; Cipher Text &ndash;Decryption(public Key)&ndash;&gt; Plain Text</li>
</ul>
<h3 id="hashing">Hashing.</h3>
<ul>
<li>It&rsquo;s a one-way encryption.</li>
<li>MD5, SHA256</li>
</ul>
<p>ref:</p>
<ul>
<li><a href="https://www.digicert.com/ssl-cryptography.htm">https://www.digicert.com/ssl-cryptography.htm</a></li>
<li><a href="https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity/56393#56393">https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity/56393#56393</a></li>
<li><a href="https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work">https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work</a></li>
</ul>
<h1 id="unix-domain-socket-aka-ipc-socket">Unix Domain Socket, aka IPC socket</h1>
<p>Unix Domain Socket is a data communications endpoint for exchanging data between processes executing on the same host operating system.
It supports transmission of a reliable stream of bytes, ordered and reliable transmission of datagrams.
The API for Unix domain sockets is similar to that of an Internet socket, but rather than using an underlying network protocol, all communication occurs entirely within the operating system kernel.
Unix domain sockets use the file system as their address name space.
Processes reference Unix domain sockets as file system inodes, so two processes can communicate by opening the same socket.
Instead of identifying a server by an IP address and port, a Unix domain socket is known by a pathname. Obviously the client and server have to agree on the pathname for them to find each other.</p>
<h3 id="rpc">RPC</h3>
<p>Remote procedure call (RPC) is an Inter-process communication technology that allows a computer program to cause a subroutine or procedure to execute in another address space (commonly on another computer on a shared network) without the programmer explicitly coding the details for this remote interaction.</p>
<p>An RPC (remote procedure call) is a form of IPC (inter-process communication)</p>
<h3 id="grpc">gRPC</h3>
<ul>
<li>Improved RPC</li>
<li>Developed by google</li>
<li>Use HTTP/2 for transport, Protocal Buffers as interface description language (protobuf)</li>
<li>Provides features such as authentication, bidirectional streaming and flow control, blocking or nonblocking bindings, and cancellation and timeouts.</li>
</ul>
<h3 id="rpc-vs-ipc">RPC vs IPC</h3>
<ul>
<li>RPC - Remote Procedure Call - is a particular type of communication, but can be on a single machine, or across a network between machines.</li>
<li>IPC - Inter-Process Communication - is a general term for communication between different processes (which are usually on a single machine).</li>
<li>RPC: remotely preferred, IPC: locally preferred</li>
</ul>
<h3 id="named-pipe-vs-ipc">Named Pipe vs IPC</h3>
<ul>
<li>Duplex: Stream sockets provide bi-directional communication while named pipes are uni-directional.</li>
<li>Distinct clients: Clients using sockets each have an independent connection to the server. With named pipes, many clients may write to the pipe, but the server cannot distinguish the clients from each other&ndash; the server has only one descriptor to read from the named pipe. Because the named pipe has only read descriptor and possibly-multiple writers, random interleaving can also occur if a client writes more than PIPE_BUF bytes in one operation. Since pipes have these limitations, UNIX domain sockets should be used if there are multiple clients that need to be distinguishable or which write long messages to the server.</li>
<li>Method of creating and opening: Sockets are created using socket and assigned their identity via bind. Named pipes are created using mkfifo. To connect to a Unix domain socket the normal socket/connect calls are used, but a named pipe is written using regular file open and write. That makes them easier to use from a shell script for example.</li>
</ul>
<p>ref:</p>
<ul>
<li><a href="https://troydhanson.github.io/network/Unix_domain_sockets.html">Unix domain sockets</a></li>
<li><a href="https://openforums.wordpress.com/2016/08/07/open-file-descriptor-passing-over-unix-domain-sockets/">PASSING OPEN FILE DESCRIPTORS OVER UNIX DOMAIN SOCKETS</a></li>
<li><a href="https://stackoverflow.com/questions/2161674/is-there-a-difference-between-rpc-and-ipc">Is there a difference between RPC and IPC?</a></li>
</ul>
<h1 id="ip-1">IP</h1>
<p>5 個 CLASS</p>
<pre><code>Class A :   0.xx.xx.xx ~ 127.xx.xx.xx       # 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   開頭是 0
Class B : 128.xx.xx.xx ~ 191.xx.xx.xx       # 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   開頭是 10
Class C : 192.xx.xx.xx ~ 223.xx.xx.xx       # 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   開頭是 110
Class D : 224.xx.xx.xx ~ 239.xx.xx.xx       # 1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   開頭是 1110
Class E : 240.xx.xx.xx ~ 255.xx.xx.xx       # 1111xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   開頭是 1111
</code></pre>
<p>Public &amp; Private</p>
<pre><code>Class A：10.0.0.0    - 10.255.255.255
Class B：172.16.0.0  - 172.31.255.255
Class C：192.168.0.0 - 192.168.255.255
</code></pre>
<h1 id="port">Port</h1>
<h3 id="web-app-開-80-port-遇到-permission-denied">Web app 開 80 port 遇到 permission denied</h3>
<p>只有 root 才可以開小於 1024 的 port，最簡單的解決方法就是先開一個高一點的 port (e.g. 8080)，再用 iptable 去 forward 80 -&gt; 8080</p>
<pre><code>iptables -t mangle -A PREROUTING -p tcp --dport 80 -j MARK --set-mark 1
iptables -t mangle -A PREROUTING -p tcp --dport 443 -j MARK --set-mark 1
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080
iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8181
iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -m mark --mark 1 -j ACCEPT
iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport 8181 -m mark --mark 1 -j ACCEPT
</code></pre>
<h1 id="vpn">VPN</h1>
<p>讓 Private 可以被特定的連線操作</p>
<ul>
<li>OpenVPN (SSL VPN) or IPsec</li>
<li>OpenVPN 安全性會比 IPsec 好</li>
</ul>
<h1 id="常用的-http-status">常用的 Http status</h1>
<ul>
<li>301 (Permanent) — Redirects to the site you specified in the Forward To field using a &ldquo;301 Moved Permanently&rdquo; HTTP response. The HTTP 301 response code tells user-agents (including search engines) that the location has permanently moved.</li>
<li>302 (Temporary) — Redirects to the site you specified in the Forward To field using a &ldquo;302 Found&rdquo; HTTP response. The HTTP 302 response code tells user-agents (including search engines) that the location has temporarily moved.</li>
<li>200 (:ok) : ok. 常用在一般 api</li>
<li>201 (:created) : 新增成功. 在 call create api 時回應</li>
<li>422 (:unprocessable_entity) : Creating a new resource is not successful. create 失敗時回應</li>
<li>204 (:no_content) : Successful responses with no content. 在 call destroy api 時回應</li>
<li>500 : internal server errors  # Rails automatically handles server errors and returns a 500 response.</li>
<li>401 : Unauthorized</li>
</ul>
<h3 id="server-回覆較常使用的">Server 回覆較常使用的</h3>
<ul>
<li>200 : 成功回覆</li>
<li>400 : Client 發送時引發的錯誤，例如參數有少</li>
<li>401 : 認證錯誤，例如 AccessToken 錯誤</li>
<li>500 : Server 內部發生錯誤，例如 DB 連線錯誤</li>
</ul>
<h1 id="traceroute-觀察-host-經過的節點狀態">traceroute 觀察 host 經過的節點狀態</h1>
<pre><code>$ traceroute google.com
traceroute to google.com (172.217.31.142), 30 hops max, 60 byte packets
 1  ec2-175-41-192-150.ap-northeast-1.compute.amazonaws.com (175.41.192.150)  16.685 ms ec2-175-41-192-144.ap-northeast-1.compute.amazonaws.com (175.41.192.144)  19.225 ms ec2-175-41-192-146.ap-northeast-1.compute.amazonaws.com (175.41.192.146)  16.309 ms
 2  100.64.1.200 (100.64.1.200)  17.298 ms 100.64.3.78 (100.64.3.78)  13.307 ms 100.64.0.78 (100.64.0.78)  21.296 ms
 3  100.66.3.36 (100.66.3.36)  17.270 ms 100.66.3.108 (100.66.3.108)  20.964 ms 100.66.3.192 (100.66.3.192)  14.131 ms
 (...略...)
16  108.170.242.193 (108.170.242.193)  4.186 ms 108.170.242.161 (108.170.242.161)  3.221 ms 108.170.242.193 (108.170.242.193)  5.237 ms
17  74.125.251.237 (74.125.251.237)  3.611 ms  3.618 ms  5.141 ms
18  nrt20s08-in-f14.1e100.net (172.217.31.142)  2.942 ms  4.001 ms  2.928 ms
</code></pre>

</article>



</html>
