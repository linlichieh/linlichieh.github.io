<!DOCTYPE html>
<html lang="en-us">
<title>Data Structures | Software engineering notes</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.104.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/index.css">
<link rel="canonical" href="/posts/data-structures/">
<link rel="alternate" type="application/rss+xml" href="" title="Software engineering notes">

<header>
  
    <a href="/" class="title">Software engineering notes</a>
  
  
</header>

<article>
  <header>
    <h1>Data Structures</h1>
    
  </header>
  <h1 id="big-o">Big O</h1>
<p>A mathematical notation used in computer science to describe the performance or complexity of an algorithm</p>
<h3 id="complexity">Complexity</h3>
<blockquote>
<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)</p>
</blockquote>
<ul>
<li>O(1) constant</li>
<li>O(logn) logarithmic
<ul>
<li>base is 2</li>
<li>an array storing 1M items, will do 19 comparison with binary search</li>
<li>binary search</li>
</ul>
</li>
<li>O(n) linear
<ul>
<li>for loop</li>
<li>an array storing 1 to 10, linear search</li>
</ul>
</li>
<li>O(nlogn) log linear
<ul>
<li>merge sort,</li>
</ul>
</li>
<li>O(n^2) quadratic
<ul>
<li>double for loop</li>
<li>bubble, insertion, selection sort</li>
</ul>
</li>
<li>O(2^n) exponential
<ul>
<li>recursive Fibonacci numbers</li>
</ul>
</li>
<li>O(n!) factorial</li>
</ul>
<h1 id="common-data-structures">Common Data Structures</h1>
<ul>
<li>arrays
<ul>
<li>Time
<ul>
<li>Access O(1)
<ul>
<li>Arrays have O(1) access time because elements are stored in a contiguous block of memory and the memory location of an element can be calculated based on its index, making it possible to access an element quickly in constant time.</li>
</ul>
</li>
<li>Search O(n)
<ul>
<li>Arrays have O(n) search time because finding a specific element typically requires checking each element one by one, and the time required to find an element is proportional to the number of elements in the array.</li>
</ul>
</li>
<li>Insertion/Deletion O(n)
<ul>
<li>Arrays have O(n) insertion and deletion time because, in general, inserting or deleting an element in the middle of an array requires shifting all the elements after the insertion or deletion point, which takes linear time proportional to the number of elements in the array.</li>
<li>For example, inserting or deleting the first item requires shifting all elements one position to the right or left.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)
<ul>
<li>The total amount of memory required to store the array is n * m bits. As the number of elements in the array grows, the amount of memory required also grows linearly, making the space complexity O(n).</li>
<li>Note that the space complexity of an array does not depend on the size of the elements, only on the number of elements.</li>
</ul>
</li>
<li>unordered data</li>
</ul>
</li>
<li>stacks
<ul>
<li>Time
<ul>
<li>Access/Search O(n)
<ul>
<li>Stacks take O(n) access time because, in general, accessing an element in a stack requires starting at the top of the stack and then following the chain of pointers to the desired element, which takes linear time proportional to the number of elements in the stack.</li>
<li>Stacks take O(n) search time because finding an element in a stack typically requires starting at the top of the stack and following the chain of pointers until the desired element is found, which takes linear time proportional to the number of elements in the stack.</li>
</ul>
</li>
<li>Insertion/Deletion O(1)
<ul>
<li>Stacks take O(1) insertion and deletion time because they follow the Last-In-First-Out (LIFO) principle, where the most recently added element is always the first to be removed. In a stack, inserting (push) or deleting (pop) an element only requires updating the top pointer, which takes constant time and does not depend on the size of the stack.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)
<ul>
<li>Stacks take O(n) space complexity because each element in a stack requires a constant amount of memory to store, and the amount of memory required by a stack is proportional to the number of elements stored in the stack.</li>
</ul>
</li>
<li>LIFO</li>
</ul>
</li>
<li>queues
<ul>
<li>Time
<ul>
<li>Access/Search O(n)
<ul>
<li>Queues take O(n) access and search time because, in general, accessing or searching for an element in a queue requires starting at one end of the queue and then following the chain of pointers until the desired element is found, which takes linear time proportional to the number of elements in the queue.</li>
</ul>
</li>
<li>Insertion/Deletion O(1)
<ul>
<li>Queues take O(n) insertion and deletion time because they follow the First-In-First-Out (FIFO) principle, where the first element added to the queue is the first to be removed. In a queue, inserting (enqueue) an element at the end of the queue and deleting (dequeue) an element from the front of the queue both require updating the front and rear pointers, which takes linear time proportional to the number of elements in the queue.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)</li>
<li>FIFO</li>
</ul>
</li>
<li>linked list
<ul>
<li>Time
<ul>
<li>Access/Search O(n)
<ul>
<li>Linked lists take O(n) access and search time because, in general, accessing or searching for an element in a linked list requires following the chain of pointers from one element to the next until the desired element is found, which takes linear time proportional to the number of elements in the linked list.</li>
</ul>
</li>
<li>Insertion/Deletion O(1)
<ul>
<li>Linked lists take O(1) insertion and deletion time because each element in a linked list is connected to its neighbors via pointers, making it possible to insert or delete an element by simply updating the pointers of the neighboring elements.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)</li>
<li>no fixed size</li>
<li>takes up space (needs to store point and metadata)</li>
<li>slow lookup (walk through each item)</li>
<li>unordered data</li>
</ul>
</li>
<li>hash tables
<ul>
<li>Time
<ul>
<li>Access N/A</li>
<li>(avg) Search/Insertion/Deletion O(1)
<ul>
<li>Hash tables can get an average time complexity of O(1) because they use a hash function to map keys to indices in an array, which allows for fast access to elements. When the hash function is well-designed and the hash table is properly balanced, each key maps to a unique index, and accessing an element in the hash table can be done in constant time.</li>
</ul>
</li>
<li>(worse) Search/Insertion/Deletion O(n)
<ul>
<li>Hash tables use a hash function to map keys to indices in an array, which allows for fast search for elements. However, if the hash function is poorly designed or the hash table becomes too full, collisions can occur, where multiple keys map to the same index.</li>
<li>In the worst case scenario, when all keys collide and map to the same index, the hash table becomes a linked list, and insertion becomes an O(n) operation because you have to traverse the linked list to find the right place to insert the new element.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)</li>
</ul>
</li>
<li>trees
<ul>
<li>Binary Search Tree
<ul>
<li>Time
<ul>
<li>(avg) Access/Search/Insertion/Deletion O(log n)
<ul>
<li>binary search trees are structured such that elements are organized in a way that allows for efficient searching, insertion, and deletion operations. When the tree is balanced, the height of the tree is logarithmic with respect to the number of elements in the tree, which results in an average time complexity of O(log n) for these operations.</li>
</ul>
</li>
<li>(worse) Access/Search/Insertion/Deletion O(n)
<ul>
<li>if the tree becomes unbalanced, the height of the tree can be proportional to the number of elements in the tree, resulting in a worst-case time complexity of O(n)</li>
</ul>
</li>
<li>Since the height of a well-balanced BST is O(log(n)), insertion takes O(log(n)) time on average. In the worst case, when the BST is not balanced and becomes a linear chain, the time complexity is O(n)</li>
</ul>
</li>
<li>Space O(n)</li>
<li>pros
<ul>
<li>better than O(n)</li>
<li>ordered</li>
<li>flexible size</li>
</ul>
</li>
<li>cons
<ul>
<li>No O(1) operations</li>
</ul>
</li>
</ul>
</li>
<li>Heap (binary heap)
<ul>
<li>Time
<ul>
<li>Insertion O(log n)
<ul>
<li>inserting a new element into a heap requires adding the element to the end of the heap and then performing a series of swaps to maintain the heap property</li>
</ul>
</li>
<li>Insert all elements O(n log n)</li>
<li>Deletion(= extract) O(log n)
<ul>
<li>deleting the root element of a heap requires replacing it with the last element in the heap and then performing a series of swaps to maintain the heap property</li>
</ul>
</li>
<li>Heapify O(log n)</li>
<li>Building a heap O(n)</li>
</ul>
</li>
<li>Space O(n)</li>
<li>pros
<ul>
<li>better than O(n)</li>
<li>priority</li>
<li>flexible size</li>
<li>fast insert</li>
</ul>
</li>
<li>cons
<ul>
<li>slow lookup</li>
</ul>
</li>
</ul>
</li>
<li>tries
<ul>
<li>Suffix Tree</li>
</ul>
</li>
<li>graphs</li>
</ul>
</li>
</ul>
<h1 id="binary-search-tree">Binary search tree</h1>
<h3 id="demonstration">Demonstration</h3>
<pre><code>               101
        33             105
     9     37      104     144
</code></pre>
<h3 id="basics">Basics</h3>
<ul>
<li>All child nodes in the tree to the right of root node must be greater than the current node</li>
<li>If the BST is balanced, the average time complexity of all operation is O(log(n)). However, the worse case (unbalance BST) would be O(n)</li>
<li>Pros
<ul>
<li>better than O(n)</li>
<li>ordered</li>
<li>Flexible size</li>
</ul>
</li>
<li>Cons
<ul>
<li>No O(1) operation</li>
</ul>
</li>
</ul>
<h3 id="the-time-complexity-of-insertion-in-a-bst">The time complexity of insertion in a BST</h3>
<p>The time complexity of inserting a new node into a binary search tree (BST) depends on the height of the tree,
and can range from O(log n) to O(n), where n is the number of nodes in the tree.</p>
<p>The time complexity of inserting a new node into a BST depends on the height of the tree.
In the best case, when the tree is balanced, the height is O(log n), and the time complexity of insertion is also O(log n).
This is because each comparison eliminates half of the remaining tree, and we need to perform at most log n comparisons to reach a leaf node.</p>
<h3 id="the-implementation-difference-between-array-and-linked-list">The implementation difference between Array and Linked List</h3>
<ul>
<li>Array: Need to move several nodes when a node is added or deleted.</li>
<li>Linked List: Improve the drewback of Array.</li>
</ul>
<h1 id="heap">Heap</h1>
<h3 id="demonstration-1">Demonstration</h3>
<p>max heap</p>
<pre><code>     90
    /   \
  60     50
 /  \   /  \
40  30 20  10
</code></pre>
<p>min heap</p>
<pre><code>     10
    /   \
  20     30
 /  \   /  \
40  60 50  70
</code></pre>
<h3 id="basics-1">Basics</h3>
<p>A Binary Heap is either Min Heap or Max Heap</p>
<ul>
<li>max-heap: root is the maximum number
<ul>
<li>Every child is less than their parent</li>
<li>It doesn&rsquo;t matter whether the left or right child is larger</li>
<li>heapify up: swap with the parent if the parent is smaller</li>
<li>heapify down: swap with biggest child if parent is less than its children</li>
</ul>
</li>
<li>min-heap: root is the minimum number
<ul>
<li>heapify up: swap with the parent if the parent is bigger</li>
<li>heapify down: swap with the smallest child if parent is bigger than its children</li>
</ul>
</li>
</ul>
<h3 id="use-cases">Use cases</h3>
<ul>
<li>heap sort</li>
<li>priority queue</li>
</ul>
<h3 id="operations">Operations</h3>
<ul>
<li>Insertion
<ul>
<li>Ensure that the tree remains balanced by adding the value to the bottom layer from left to right</li>
<li>Maintain the features of a min/max heap by swapping nodes all the way to the top if needed</li>
</ul>
</li>
<li>Deletion
<ul>
<li>Remove the root node, then replace it with the node from the bottom-rightmost layer of the heap</li>
<li>Maintain the features of a min/max heap by swapping nodes all the way to the bottom if needed</li>
</ul>
</li>
</ul>
<h3 id="the-difference-of-implementation-between-array-and-linked-list">The difference of implementation between array and linked list</h3>
<ul>
<li>array (preferred)
<ul>
<li>pros
<ul>
<li>Easy implementation
<ul>
<li>easy to compute the array index of a node&rsquo;s children</li>
<li>more efficient to find the Kth element of an array than the Kth element of a linked list</li>
</ul>
</li>
<li>Good for time complexity
<ul>
<li>efficient operations such as inserting a new element, deleting the minimum (or maximum) element, and finding the minimum (or maximum) element, which can be done in O(log n) time.</li>
</ul>
</li>
<li>in-place algorithm</li>
</ul>
</li>
<li>cons
<ul>
<li>Memory reallocation: if the heap grows beyond its initial size, it must be resized, leading to wasted space and increased memory usage</li>
</ul>
</li>
</ul>
</li>
<li>linked list
<ul>
<li>pros
<ul>
<li>Dynamic memory allocation: using pointers its easier to grow the data structure size dynamically, you can insert new elements without worrying about reallocating memory</li>
</ul>
</li>
<li>cons
<ul>
<li>Difficult implementation (compared to array)</li>
<li>Bad for time complexity: finding the minimum (or maximum) element, inserting a new element, and deleting the minimum (or maximum) element all have a time complexity of O(n) in the worst case because it may require traversing the entire list to find a specific element</li>
<li>O(n) space</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>How do I make decision which implementation to use, arrays or linked lists?</p>
<ul>
<li>If the array size changes frequently and array is huge
<ul>
<li>yes -&gt; linked list</li>
<li>no -&gt; array</li>
</ul>
</li>
<li>If the performance of operations such as insertion, deletion matters
<ul>
<li>yes -&gt; array</li>
<li>no -&gt; linked list</li>
</ul>
</li>
</ul>
<h3 id="why-does-heap-sort-require-on-log-n-time">Why does heap sort require O(n log n) time?</h3>
<p>The time complexity for heap sort is the sum of the two stages:
<code>O(n)</code> time for building the heap and <code>O(n log n)</code> to remove each node in order. Therefore, the overall time complexity is <code>O(n log n)</code>.</p>
<h3 id="build-a-heap-by-inserting-all-elements-on-logn">Build a heap by inserting all elements O(n logn)</h3>
<p>each insertion takes O(log n) time, and we perform this n times, resulting in O(n * log n) time complexity</p>
<h3 id="build-a-heap-from-unsorted-binary-tree-on">Build a heap from unsorted binary tree O(n)</h3>
<p>Heapify works by processing the elements from the middle of the array to the beginning, rearranging elements to satisfy the heap property. Since the majority of elements are located in the lower part of the heap (which requires less work to rearrange), the overall time complexity is reduced to O(n)</p>
<h3 id="why-does-building-a-heap-take-on-siftdown">Why does building a heap take O(n)? (siftDown)</h3>
<p>n = 31, h = log n = 5</p>
<pre><code>                         E                                  h=4
                        / \
                      /     \
                    /         \
                  /             \
                /                 \
              /                     \
            /                         \
           D                           D                    h=3
         /   \                       /   \
       /       \                   /       \
     C           C               C           C              h=2
   /   \       /   \           /   \       /   \
  B     B     B     B         B     B     B     B           h=1
 / \   / \   / \   / \       / \   / \   / \   / \
A   A A   A A   A A   A     A   A A   A A   A A   A         h=0
</code></pre>
<p>Explanation</p>
<ul>
<li>there are 16 <code>A</code> nodes at height 0 (n/2^1 = 31/2 = 16)</li>
<li>there are 8 <code>B</code> nodes at height 1 (n/2^2 = 31/4 = 8)</li>
<li>there are 4 <code>C</code> nodes at height 2 (n/2^3 = 31/8 = 4)</li>
<li>there are 2 <code>D</code> nodes at height 3 (n/2^4 = 31/16 = 2)</li>
<li>there is 1 <code>E</code> node at height 4 (n/2^5 = 31/32 = 1)</li>
</ul>
<p>there are n/2^(h+1) nodes at level <code>h</code>, each node will perform at most <code>h</code> times of swap</p>
<p>For example, in the case of node <code>C</code>, it will swap at most 2 times to reach the bottom</p>
<p>the total work of swap in worse case will be</p>
<pre><code>        A              B             C            D             E
    (n/2^1 * 0) + (n/2^2 * 1) + (n/2^3 * 2) + (n/2^4 * 3) + (n/2^(h+1) * h)
=    (n/2 * 0)  +  (n/4 * 1)  +  (n/8 * 2)  +  (2/16 * 3) +   (31/32 * 4)
=       16*0    +    8*1      +     4*2     +    2*3      +     1*4
=    26
</code></pre>
<p>the time complexity is <code>O(n)</code></p>
<p>the proof is too complicated to me, please see <a href="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity">https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity</a> if you are interested in</p>
<h3 id="the-difference-between-siftup-and-sift-down">The difference between siftUp and sift Down</h3>
<p>siftUp</p>
<ul>
<li>O(n log n)</li>
<li>siftUp operation is only needed to perform inserts into an existing heap</li>
<li>be used to implement a priority queue using a binary heap</li>
</ul>
<p>siftDown</p>
<ul>
<li>O(n)</li>
<li>buildHeap (build the heap from a binary tree) and heapSort will only use siftDown</li>
</ul>
<h3 id="which-is-more-efficient-siftup-or-siftdown">Which is more efficient, siftUp or siftDown?</h3>
<p>siftDown</p>
<pre><code>(0 * n/2) + (1 * n/4) + (2 * n/8) + ... + (h * 1)
</code></pre>
<blockquote>
<p>O(n)</p>
</blockquote>
<p>siftUp</p>
<pre><code>(h * n/2) + ((h-1) * n/4) + ((h-2)*n/8) + ... + (0 * 1)
</code></pre>
<blockquote>
<p><code>(h * n/2)</code> = <code>log n * n/2</code> = <code>n log n</code> (the first one alone takes <code>n log n</code>)</p>
</blockquote>
<p>If we need to apply an operation to every node, it is preferable to use siftDown rather than siftUp.</p>
<h1 id="graph">Graph</h1>
<h3 id="basics-2">basics</h3>
<p>Components</p>
<ul>
<li>vertex (node)</li>
<li>edge (arc)</li>
</ul>
<p>Types</p>
<ul>
<li>directed graph
<ul>
<li>u -&gt; v</li>
<li>(u, v)</li>
</ul>
</li>
<li>un-directed graph
<ul>
<li>u &ndash; v</li>
<li>(u, v) and (v, u) are same</li>
</ul>
</li>
</ul>
<h3 id="implementation-using-edge-list">Implementation using Edge list</h3>
<p>graph using array</p>
<pre><code>        2 ---------- 0
      /   \
     1-----3
</code></pre>
<p>represent in code</p>
<pre><code>graph = [[0,2], [2,3], [2,1], [1,3]]
</code></pre>
<blockquote>
<p>Each array element represents a connection between two nodes in the graph</p>
</blockquote>
<p>pros</p>
<ul>
<li>Simple Representation: each pair in the list represents an edge</li>
<li>Space Efficiency for Sparse Graphs: the number of edges is much less than the square of the number of vertices</li>
<li>Easy Addition of Edges: just append a new pair to the list, which takes O(1), assuming you don&rsquo;t have to check for duplicates</li>
</ul>
<p>cons</p>
<ul>
<li>Inefficient for Dense Graphs: For dense graphs (where the number of edges is close to the square of the number of vertices)</li>
<li>Slow Lookup: Checking whether an edge exists between two vertices can be slow, as it may require scanning the entire list, which take O(Edge)</li>
<li>No Quick Adjacency Information: Unlike adjacency lists or matrices, edge lists don&rsquo;t provide a fast way to find all vertices adjacent to a given vertex. You would need to traverse the entire list and pick out the edges for the given vertex</li>
<li>Duplicate and Loop Checking: If you need to ensure that there are no duplicate edges or loops in your graph, you&rsquo;ll need to do extra work every time you add an edge. In the worst case, this could involve scanning the entire list.</li>
</ul>
<p>use cases</p>
<ul>
<li>suitable for sparse graph</li>
</ul>
<h3 id="implementation-using-adjacent-list">Implementation using Adjacent list</h3>
<p>graph</p>
<pre><code>        2 ---------- 0
      /   \
     1-----3
</code></pre>
<p>represent in code using array of linked list</p>
<pre><code>graph = [[2], [2,3], [0,1,3], [1,2]]
</code></pre>
<blockquote>
<ul>
<li>Each array element&rsquo;s index represents a node in the graph, and the values within that element represent connections to that node.</li>
<li>For instance, the index 0 <code>[2]</code> represents a connection between nodes 0 and 2, while the index 1 <code>[2,3]</code> indicates connections between nodes 1 and 2, as well as node 1 and 3.</li>
</ul>
</blockquote>
<p>pros</p>
<ul>
<li>Space Efficient
<ul>
<li>only store the nodes that actually exists in the graph</li>
<li>This works nicely in all kinds of graphs, either dense or sparse, since the maximum space usage is always smaller than N^2</li>
</ul>
</li>
<li>Dynamic Allocation
<ul>
<li>allows for dynamic allocation of memory, making it easier to add or remove vertices and edges from the graph</li>
</ul>
</li>
<li>fast to iterate all edges
<ul>
<li>Iterating over all edges in an adjacency list representation is easier and faster compared to an adjacency matrix representation, especially for sparse graphs</li>
</ul>
</li>
</ul>
<p>cons</p>
<ul>
<li>Slow to accessing a specific edge / slow to determine if 2 nodes are connected
<ul>
<li>need to list all the nodes that the node is connected to</li>
<li>O(N)</li>
</ul>
</li>
</ul>
<p>use cases</p>
<ul>
<li>Adjacency list is much more efficient for the storage of the graph, especially sparse graphs, when there is a lot less edges than nodes.</li>
<li>suitable for sparse graph</li>
</ul>
<h3 id="implementation-using-adjacent-matrix">Implementation using Adjacent matrix</h3>
<p>graph</p>
<pre><code>        2 ---------- 0
      /   \
     1-----3
</code></pre>
<p>represent in code using array</p>
<pre><code>graph = {
    [0,0,1,0],
    [0,0,1,1],
    [1,1,0,1],
    [0,1,1,0]
}
</code></pre>
<blockquote>
<ul>
<li>It has a similar concept to adjacent list.</li>
<li>The index 0 in the 2-dimensional array represents node 0 in the graph, and the presence of a value 1 at a particular index within that array element signifies a connection between node 0 and the node represented by that index.</li>
<li>For example, the index 0 <code>[0,0,1,0]</code> represents a connection between node 0 and node 2, while the index 2 <code>[1,1,0,1]</code> indicates connections between node 2 and node 0, node 2 and node 1, as well as node 2 and node 3.</li>
</ul>
</blockquote>
<p>pros</p>
<ul>
<li>easy to implement</li>
<li>Accessing and updating information about an edge take O(1) time
<ul>
<li>determine if two vertices are adjacent to each other</li>
<li>add an edge in the graph</li>
<li>delete an edge form the graph</li>
</ul>
</li>
</ul>
<p>cons</p>
<ul>
<li>consume more memory O(V^2)
<ul>
<li>if there is a graph with 1000 vertices and 1 edge, in order to store on edge it takes an array of size 1000^2 in memory</li>
<li>not good for a sparse graph</li>
</ul>
</li>
<li>Traversing the graph using algorithms like DPS/BFS requires O(V^2) time
<ul>
<li>very slow for algorithms that require iterating over all edges, as the number of edges is proportional to n^2.</li>
</ul>
</li>
</ul>
<p>use cases</p>
<ul>
<li>If the graph contains edges in order of V2, then it is better to use adjacency matrix as compared to adjacency list. This is because the size of both adjacency list and adjacency matrix will be comparable so using adjacecny matrix doesn’t necceessary waste a lot of memeory.</li>
<li>If we want to perform operations like add/delete or check that the vertices are adjancent or not very frequently, then it is recommended to use adjacency matrix since we can perform these operations in constant time.</li>
<li>suitable for dense graph</li>
</ul>
<h1 id="trie">Trie</h1>
<h3 id="basics-3">basics</h3>
<ul>
<li>a tree-like data strucutre</li>
<li>can have more than 2 children</li>
<li>used for search string (like search engine)</li>
</ul>
<h3 id="represent-a-trie-using-linked-list">Represent a trie using linked list</h3>
<p>linked list attributes</p>
<ul>
<li>map[string]*node
<ul>
<li>string is a character</li>
</ul>
</li>
<li>isWord (boolean)</li>
</ul>
<p>trie: <code>[&quot;cat&quot;, &quot;tr&quot;, &quot;trid&quot;, &quot;trie&quot;, &quot;trief&quot;]</code></p>
<pre><code>      [   &quot;c&quot;      &quot;t&quot;    ]
        (false)   (false)
         /            \
      [&quot;a&quot;]          [&quot;r&quot;]
     (false)         (true)
      /                  \
   [&quot;t&quot;]                [&quot;i&quot;]
  (true)               (false)
                            \
                      [  &quot;d&quot;    &quot;e&quot;  ]
                       (true)  (true)
                                   \
                                  [&quot;f&quot;]
                                  (true)
</code></pre>
<h3 id="ref">ref</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=_r7cfVrn28c">https://www.youtube.com/watch?v=_r7cfVrn28c</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/binary-search-tree-bst-search-insert-remove">https://www.digitalocean.com/community/tutorials/binary-search-tree-bst-search-insert-remove</a></li>
<li>Delete a node in BST <a href="https://www.youtube.com/watch?v=DkOswl0k7s4">https://www.youtube.com/watch?v=DkOswl0k7s4</a></li>
<li>Delete a node in BST <a href="https://www.educative.io/answers/how-to-delete-a-node-from-a-binary-search-tree">https://www.educative.io/answers/how-to-delete-a-node-from-a-binary-search-tree</a></li>
<li>Delete a node in BST <a href="https://www.techiedelight.com/deletion-from-bst/">https://www.techiedelight.com/deletion-from-bst/</a></li>
<li>graph <a href="https://slaystudy.com/advantages-and-disadvantages-of-adjacency-matrix-graph-representation/">https://slaystudy.com/advantages-and-disadvantages-of-adjacency-matrix-graph-representation/</a></li>
<li>graph <a href="https://www.quora.com/What-are-the-pros-and-cons-of-representing-a-graph-in-an-adjacency-list-an-adjacency-matrix-and-objects-classes">https://www.quora.com/What-are-the-pros-and-cons-of-representing-a-graph-in-an-adjacency-list-an-adjacency-matrix-and-objects-classes</a></li>
<li>how graph shows directed graph using adjacency list and matrix <a href="https://www.softwaretestinghelp.com/graph-implementation-cpp/">https://www.softwaretestinghelp.com/graph-implementation-cpp/</a></li>
</ul>

</article>



</html>
