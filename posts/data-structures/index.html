<!DOCTYPE html>
<html lang="en-us">
<title>Data Structures | Software</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.104.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/index.css">
<link rel="canonical" href="/posts/data-structures/">
<link rel="alternate" type="application/rss+xml" href="" title="Software">

<header>
  
    <a href="/" class="title">Software</a>
  
  
</header>

<article>
  <header>
    <h1>Data Structures</h1>
    <time datetime="2017-05-20T18:53:13&#43;08:00">May 20, 2017</time>
  </header>
  <h1 id="時間複雜度-on-big-o-notation">時間複雜度 O(n), Big O notation</h1>
<p>用來比較不同演算法花多少時間的方法</p>
<h3 id="變因">變因</h3>
<ul>
<li>除法比加法慢一點</li>
<li>記憶體存取區塊不同也有差異</li>
<li>測試規模大的時候能測的比較準確</li>
<li>操作次數的量級重要於精確的值</li>
</ul>
<h3 id="計算">計算</h3>
<ul>
<li>假設所有操作都是一樣的時間 (加減乘除/取餘數/存取記憶體/判斷運算子)</li>
<li>假設演算法 3n^2 + 2n + 7, 電腦每秒執行 100萬次, n=2000, 需要 12,004,007 次的加法操作才能解決此問題, 此電腦需要 12 秒才能跑完</li>
<li>一般電腦是 2,000~8,000萬次/秒</li>
<li>Big-O : O(f(n))</li>
<li>Little-o : o(f(n))</li>
<li>n 是輸入的規模</li>
</ul>
<h3 id="常見的幾種時間複雜度與演算法">常見的幾種時間複雜度與演算法</h3>
<p>O(n!) &gt; O(2^n) &gt; O(n^2) &gt; O(nlogn) &gt; O(n) &gt; O(logn) &gt; O(1)</p>
<ul>
<li>O(1) constant
<ul>
<li>陣列讀取 (已經知道要從陣列取出哪一個 index)</li>
</ul>
</li>
<li>O(logn) logarithmic
<ul>
<li>base is 2</li>
<li>an array storing 1M items, will do 19 comparison with binary search</li>
<li>二分搜尋 (從小到大的排列裡面每次搜尋都取中間值)</li>
</ul>
</li>
<li>O(n) linear
<ul>
<li>簡易搜尋 (搜尋時從頭跑到尾)</li>
<li>for loop</li>
<li>an array storing 1 to 10, linear search</li>
<li>String[] copy = new String[names.length]</li>
</ul>
</li>
<li>O(nlogn) log linear
<ul>
<li>合併排序 (把大陣列一直重覆切一半成小陣列, 直到所有小陣列都只有一個元素, 再重覆將兩個小陣列合併成一個陣列, 直到所有陣列都合併成一個大陣列) <a href="https://commons.wikimedia.org/wiki/File:Merge-sort-example-300px.gif">gif demonstration</a></li>
</ul>
</li>
<li>O(n^2) quadratic
<ul>
<li>double for loop</li>
<li>選擇排序 (從未排序的數字中找出最小值, 再丟到最左邊)</li>
<li>插入排序 (從未排序的數字讀出一個數, 根據大小把它往前插入到適當的位置) <a href="https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif">gif demonstration</a></li>
</ul>
</li>
<li>O(2^n) exponential
<ul>
<li>recursive 費波那契數列 (Fibonacci numbers) (是指在一串數字中每一項是前兩項的和 e.g. <code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</code>, 當 n 不是 0 或 1 時, <code>fibo(n) = fibo(n-1) + fibo(n-2)</code>)</li>
</ul>
</li>
<li>O(n!) factorial</li>
</ul>
<h1 id="common-data-structures">Common Data Structures</h1>
<ul>
<li>arrays
<ul>
<li>Time
<ul>
<li>Access O(1)
<ul>
<li>Arrays have O(1) access time because elements are stored in a contiguous block of memory and the memory location of an element can be calculated based on its index, making it possible to access an element quickly in constant time.</li>
</ul>
</li>
<li>Search O(n)
<ul>
<li>Arrays have O(n) search time because finding a specific element typically requires checking each element one by one, and the time required to find an element is proportional to the number of elements in the array.</li>
</ul>
</li>
<li>Insertion/Deletion O(n)
<ul>
<li>Arrays have O(n) insertion and deletion time because, in general, inserting or deleting an element in the middle of an array requires shifting all the elements after the insertion or deletion point, which takes linear time proportional to the number of elements in the array.</li>
<li>For example, inserting or deleting the first item requires shifting all elements one position to the right or left.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)
<ul>
<li>The total amount of memory required to store the array is n * m bits. As the number of elements in the array grows, the amount of memory required also grows linearly, making the space complexity O(n).</li>
<li>Note that the space complexity of an array does not depend on the size of the elements, only on the number of elements.</li>
</ul>
</li>
<li>unordered data</li>
</ul>
</li>
<li>stacks
<ul>
<li>Time
<ul>
<li>Access/Search O(n)
<ul>
<li>Stacks take O(n) access time because, in general, accessing an element in a stack requires starting at the top of the stack and then following the chain of pointers to the desired element, which takes linear time proportional to the number of elements in the stack.</li>
<li>Stacks take O(n) search time because finding an element in a stack typically requires starting at the top of the stack and following the chain of pointers until the desired element is found, which takes linear time proportional to the number of elements in the stack.</li>
</ul>
</li>
<li>Insertion/Deletion O(1)
<ul>
<li>Stacks take O(1) insertion and deletion time because they follow the Last-In-First-Out (LIFO) principle, where the most recently added element is always the first to be removed. In a stack, inserting (push) or deleting (pop) an element only requires updating the top pointer, which takes constant time and does not depend on the size of the stack.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)
<ul>
<li>Stacks take O(n) space complexity because each element in a stack requires a constant amount of memory to store, and the amount of memory required by a stack is proportional to the number of elements stored in the stack.</li>
</ul>
</li>
<li>LIFO</li>
</ul>
</li>
<li>queues
<ul>
<li>Time
<ul>
<li>Access/Search O(n)
<ul>
<li>Queues take O(n) access and search time because, in general, accessing or searching for an element in a queue requires starting at one end of the queue and then following the chain of pointers until the desired element is found, which takes linear time proportional to the number of elements in the queue.</li>
</ul>
</li>
<li>Insertion/Deletion O(1)
<ul>
<li>Queues take O(n) insertion and deletion time because they follow the First-In-First-Out (FIFO) principle, where the first element added to the queue is the first to be removed. In a queue, inserting (enqueue) an element at the end of the queue and deleting (dequeue) an element from the front of the queue both require updating the front and rear pointers, which takes linear time proportional to the number of elements in the queue.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)</li>
<li>FIFO</li>
</ul>
</li>
<li>linked list
<ul>
<li>Time
<ul>
<li>Access/Search O(n)
<ul>
<li>Linked lists take O(n) access and search time because, in general, accessing or searching for an element in a linked list requires following the chain of pointers from one element to the next until the desired element is found, which takes linear time proportional to the number of elements in the linked list.</li>
</ul>
</li>
<li>Insertion/Deletion O(1)
<ul>
<li>Linked lists take O(1) insertion and deletion time because each element in a linked list is connected to its neighbors via pointers, making it possible to insert or delete an element by simply updating the pointers of the neighboring elements.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)</li>
<li>no fixed size</li>
<li>takes up space (needs to store point and metadata)</li>
<li>slow lookup (walk through each item)</li>
<li>unordered data</li>
</ul>
</li>
<li>hash tables
<ul>
<li>Time
<ul>
<li>Access N/A</li>
<li>(avg) Search/Insertion/Deletion O(1)
<ul>
<li>Hash tables can get an average time complexity of O(1) because they use a hash function to map keys to indices in an array, which allows for fast access to elements. When the hash function is well-designed and the hash table is properly balanced, each key maps to a unique index, and accessing an element in the hash table can be done in constant time.</li>
</ul>
</li>
<li>(worse) Search/Insertion/Deletion O(n)
<ul>
<li>Hash tables use a hash function to map keys to indices in an array, which allows for fast search for elements. However, if the hash function is poorly designed or the hash table becomes too full, collisions can occur, where multiple keys map to the same index.</li>
<li>In the worst case scenario, when all keys collide and map to the same index, the hash table becomes a linked list, and insertion becomes an O(n) operation because you have to traverse the linked list to find the right place to insert the new element.</li>
</ul>
</li>
</ul>
</li>
<li>Space O(n)</li>
</ul>
</li>
<li>trees
<ul>
<li>Binary Search Tree
<ul>
<li>Time
<ul>
<li>(avg) Access/Search/Insertion/Deletion O(log(n))
<ul>
<li>binary search trees are structured such that elements are organized in a way that allows for efficient searching, insertion, and deletion operations. When the tree is balanced, the height of the tree is logarithmic with respect to the number of elements in the tree, which results in an average time complexity of O(log n) for these operations.</li>
</ul>
</li>
<li>(worse) Access/Search/Insertion/Deletion O(n)
<ul>
<li>if the tree becomes unbalanced, the height of the tree can be proportional to the number of elements in the tree, resulting in a worst-case time complexity of O(n)</li>
</ul>
</li>
<li>Since the height of a well-balanced BST is O(log(n)), insertion takes O(log(n)) time on average. In the worst case, when the BST is not balanced and becomes a linear chain, the time complexity is O(n)</li>
</ul>
</li>
<li>Space O(n)</li>
</ul>
</li>
</ul>
</li>
<li>tries</li>
<li>graphs</li>
</ul>
<h3 id="demonstrate-time-complexity-using-code">Demonstrate time complexity using code</h3>
<p>O(1) or constant time</p>
<pre><code>function printFirstItem($arrayOfItems)
{
    print $arrayOfItems[0] . &quot;\n&quot;;
}
</code></pre>
<blockquote>
<p>不論 array 數量是 1 還是 1000, 這個 function 都只需要一步就完成</p>
</blockquote>
<p>O(n) or linear time</p>
<pre><code>function printAllItems($arrayOfItems)
{
    foreach ($arrayOfItems as $item) {
        print $item . &quot;\n&quot;;
    }
}
</code></pre>
<blockquote>
<p>n 指的是 array 的數量, 有幾個就會有幾個動作</p>
</blockquote>
<p>log(n)</p>
<pre><code>function sayHiNTimes($n)
{
    for ($i = 0; $i &lt; $n; $i++) {
        print &quot;hi\n&quot;;
    }
}
</code></pre>
<p>log(2n) = log(n)</p>
<pre><code>function printAllItemsTwice($theArray)
{
    foreach ($theArray as $item) {
        print $item . &quot;\n&quot;;
    }

    // once more, with feeling
    foreach ($theArray as $item) {
        print $item . &quot;\n&quot;;
    }
}
</code></pre>
<p>log(1+n/2+1000) = log(n)</p>
<pre><code>function printFirstItemThenFirstHalfThenSayHi100Times($theArray)
{
    print $theArray[0] . &quot;\n&quot;;

    $middleIndex = floor(count($theArray) / 2);
    $index = 0;

    while ($index &lt; $middleIndex) {
        print $theArray[$index] . &quot;\n&quot;;
        $index++;
    }

    for ($i = 0; $i &lt; 100; $i++) {
        print &quot;hi\n&quot;;
    }
}
</code></pre>
<blockquote>
<p>如果 n 是很大的數, <code>+1000</code> 或 <code>除2</code> 會造成的影響沒有這麼大, 我們可以直接忽略</p>
</blockquote>
<p>O(n^2) or quadratic time</p>
<pre><code>function printAllPossibleOrderedPairs($arrayOfItems)
{
    foreach ($arrayOfItems as $firstItem) {
        foreach ($arrayOfItems as $secondItem) {
            print &quot;$firstItem, $secondItem\n&quot;;
        }
    }
}
</code></pre>
<blockquote>
<p>n 指的是 array 的數量, 此 function 會做 n^2 個動作</p>
</blockquote>
<p>O(n+n2) = O(n^2)</p>
<pre><code>function printAllNumbersThenAllPairSums($arrayOfNumbers)
{
    print &quot;these are the numbers\n&quot;;
    foreach ($arrayOfNumbers as $number) {
        print $number . &quot;\n&quot;;
    }

    print &quot;and these are their sums:\n&quot;;
    foreach ($arrayOfNumbers as $firstNumber) {
        foreach ($arrayOfNumbers as $secondNumber) {
            print $firstNumber + $secondNumber . &quot;\n&quot;;
        }
    }
}
</code></pre>
<p>其他</p>
<ul>
<li>3n^3 + 5n^2 + 10n + 3 = O(n^3)</li>
<li>1000 = O(1)</li>
<li>3n^2+n+20 = O(n^2)</li>
<li>100n = O(n)</li>
<li>n^100 = O(n^100)</li>
<li>2^n = O(2^n)</li>
<li>n^2 = O(n^2)</li>
<li>10nlog n = O(nlog n)</li>
<li>100^n = O(100^n)</li>
<li>n! = O(n!)</li>
<li>30*2^n = O(2^n)</li>
<li>100n = O(n)</li>
</ul>
<h3 id="demonstrate-space-complexity-using-code">Demonstrate space complexity using code</h3>
<p>O(1) space</p>
<pre><code>function sayHiNTimes($n)
{
    for ($i = 0; $i &lt; $n; $i++) {
        print &quot;hi\n&quot;;
    }
}
</code></pre>
<p>O(n) space</p>
<pre><code>function arrayOfHiNTimes($n)
{
    $hiArray = [];
    for ($i = 0; $i &lt; $n; $i++) {
        $hiArray[$i] = 'hi';
    }
    return $hiArray;
}
</code></pre>
<p>其他</p>
<ul>
<li>O(logN) - logarithmic</li>
<li>O(NlogN) - loglinear</li>
<li>O(2^N) - exponential time</li>
<li>O(n^2 /2+100n) = O(n^2)</li>
<li>O(n^3+50n^2+10000) = O(n^3)</li>
<li>O((n+30)*(n+5)) = O(n^2)</li>
<li>O(f(n)) + O(g(n)) is O( f(n) + g(n) ) is O( max(f(n),g(n)) )</li>
<li>O(N) + O(Log N)  =  O(N + Log N)  =  O(max(N,Log N)) = O(N)</li>
<li>O(N) + O(N)  =  O(2N)  =  O(N)</li>
</ul>
<h1 id="list-鏈結串列-或串列">List 鏈結串列 (或串列)</h1>
<ul>
<li>基本單元是 Node (data + pointer)</li>
<li>每個 node 只記錄下一個 node 的位置</li>
<li>起點 (head) 指標指向第一個 node, 最後一個 node 的指標指向 NULL</li>
<li>分類: 單向 / 雙向 / 環狀</li>
<li>操作: insert / delete</li>
<li>優點
<ul>
<li>動態宣告記憶體, 避免記憶體浪費(但 dynamic array 也可以)</li>
<li>快速插入和刪除節點, 只需要更改 pointer 的值, O(1) (array 沒辦法除非要搬元素)</li>
<li>A linked list provides a data structure similar to an array, but with the big advantage that inserting an element in the middle of the list is very cheap, compared to doing so in an array, where we need to shift all elements after the current position.</li>
</ul>
</li>
<li>缺點
<ul>
<li>不能隨機存取 (random access), 不像陣列可以指定取第100個元素</li>
</ul>
</li>
<li>搜尋的時間複雜度是 O(n)</li>
<li>insert / delete 知道位置的話, 時間複雜度是 O(1), 否則必須先搜尋</li>
<li>無 index, 不支援二分搜尋法</li>
<li>串列其實是用陣列實作, 散列在記憶體裡</li>
</ul>
<h3 id="單向">單向</h3>
<ul>
<li>insert: O(1)</li>
<li>delete: O(1)</li>
</ul>
<p>Code:</p>
<pre><code>struct Node{
    int     _data;
    Node*   _next;   // 指標
}

int main() {
    Node* head;     // 紀錄起點
}
</code></pre>
<h3 id="雙向-doubly-linked-list">雙向 (doubly linked list)</h3>
<ul>
<li>每個 node 紀錄上一個跟下一個的位置</li>
<li>跟單向比的好處是它可以 start from the end and go backward</li>
</ul>
<h3 id="環狀">環狀</h3>
<ul>
<li>head 指向第一個</li>
<li>end 指向第一個</li>
</ul>
<h3 id="時間複雜度">時間複雜度</h3>
<ul>
<li>random access
<ul>
<li>Array: Yes</li>
<li>Linked List: No</li>
</ul>
</li>
<li>push front
<ul>
<li>Array: <strong>先把其他的元素往後退一格</strong>, 再插入要的元素到第一格, O(n)</li>
<li>Linked List: 只需要修改 pointer, O(1)</li>
</ul>
</li>
<li>push back
<ul>
<li>Array: 只需要把元素放到最尾端, O(1)</li>
<li>Linked List: 只需要修改 pointer, O(1)</li>
</ul>
</li>
<li>pop front
<ul>
<li>Array: O(n)</li>
<li>Linked List: O(1)</li>
</ul>
</li>
<li>pop back
<ul>
<li>Array: O(1)</li>
<li>Linked List: O(1)</li>
</ul>
</li>
</ul>
<h1 id="stack-堆疊">Stack 堆疊</h1>
<ul>
<li>First In Last Out</li>
<li>就像 &ldquo;疊盤子&rdquo;</li>
<li>實作: 陣列或 linked list</li>
<li>操作: push / pop, O(1)</li>
<li>搜尋需時 O(n)</li>
</ul>
<h3 id="陣列實作">陣列實作</h3>
<ul>
<li>用變數 top 紀錄頂端位置</li>
<li>top=-1 代表 stack 是空的</li>
<li>push: top+1, O(1)</li>
<li>pop: top-1, O(1)</li>
</ul>
<p>實作流程:</p>
<pre><code>操作      結果      stack
---------------------------
                   top=-1
push 1             top=0
push 2             top=1
pop      2         top=0
push 3             top=1
pop      3         top=0
pop                top=-1
</code></pre>
<h3 id="linked-list-實作">linked list 實作</h3>
<ul>
<li>push: 在 head 前插入一個節點</li>
<li>pop: 刪除 head 指向的節點</li>
<li>O(1)</li>
</ul>
<h1 id="queue-佇列">Queue 佇列</h1>
<ul>
<li>First In First Out</li>
<li>就像 &ldquo;排隊&rdquo;</li>
<li>分類: 單向 / 環狀</li>
<li>操作: push / pop, O(1)</li>
<li>搜尋需時 O(n)</li>
</ul>
<h3 id="陣列實作-1">陣列實作</h3>
<ul>
<li>用變數 front 紀錄最前面元素的 &ldquo;前一格&rdquo; 位置</li>
<li>用變數 rear 紀錄最後面元素的位置</li>
<li>front=rear 代表 queue 是空的</li>
<li>push: rear+1, O(1)</li>
<li>pop: front+1, O(1)</li>
</ul>
<p>實作流程:</p>
<pre><code>操作      結果      stack
---------------------------
                   front=rear=0
push 1             front=0, rear=1
push 2             front=0, rear=2
pop      1         front=1, rear=2
push 3             front=1, rear=3
pop      2         front=2, rear=3
pop      3         front=3=rear=3
</code></pre>
<ul>
<li>問題: 一旦元素被 pop, 該位置就無法再放新的</li>
<li>解決方法:
<ul>
<li>rear 到陣列最後的時候, 將所有元素往前移 =&gt; 不好, 有1000個元素要做1000次, O(n)</li>
<li>使用環狀 queue =&gt; OK, O(1)</li>
<li>使用 linked list</li>
</ul>
</li>
</ul>
<h3 id="linked-list-實作-1">linked list 實作</h3>
<ul>
<li>要多記錄 linked list 的尾端(end)</li>
<li>push: 在 end 後面插入一個節點</li>
<li>pop: 刪除 head 指向的節點</li>
<li>O(1)</li>
</ul>
<h1 id="tree">Tree</h1>
<ul>
<li>任何一點都可以當 root</li>
<li>任兩點有一條唯一的路徑可以通過</li>
<li>1 顆樹有 N-1 條邊</li>
<li>用 Dynamic array 或 Linked list 實作</li>
<li>遍歷 : 從 root 開始走遍所有 node 並印出來 (同層的話都是先走左邊)
<ul>
<li>DFS (depth-first search 深度優先) : 先往下走 (深)</li>
<li>BFS (breadth-first search 廣度優先) : 同一層走完再往下層走</li>
</ul>
</li>
</ul>
<h3 id="binary-tree">Binary tree</h3>
<ul>
<li>每個節點最多只有兩個字節點</li>
<li>K 層最多有 2^k 個節點</li>
<li>深度為 k 的 binary tree, 最多有 12^(k+1) - 1 個節點</li>
<li>遍歷: 前序/中序/後序, 差別是什麼時候印出 node 的值</li>
</ul>
<h3 id="complete-binary-tree">Complete binary tree</h3>
<ul>
<li>
<p>除了最後一層, 每一層都是填滿的</p>
</li>
<li>
<p>最後一層的元素往左靠</p>
</li>
<li>
<p>編號為 k 的兩個 child 分別為 2k 和 2k+1</p>
</li>
<li>
<p>編號為 k 的 parent 編號為 [k/2] (<strong>中括號是無條件括去的意思</strong>)</p>
</li>
<li>
<p>一個有 n 元素的 complete binary tree, 深度為 log2(n)</p>
</li>
<li>
<p>可以直接用陣列存 <code>1|2|3|4|5</code>, 用上述的算式可以算出 child 及 parent</p>
<p>Tree:
1
2       3</p>
<p>1&rsquo;s first child: 2k = 2
1&rsquo;s second child: 2k+1 = 3
2&rsquo;s parent: 2/2 = 1
3&rsquo;s parent: [3/2] = 1</p>
</li>
</ul>
<h1 id="binary-search-tree">Binary search tree</h1>
<h3 id="concept">Concept</h3>
<p>rules:</p>
<ul>
<li>all child nodes in the tree to the right of root node must be greater than the current node</li>
</ul>
<p>example:</p>
<pre><code>               101
        33             105
     9     37      104     144
</code></pre>
<p>key points</p>
<ul>
<li>If the BST is balanced, the average time complexity is O(log(n)). However, the worse case (unbalance BST) would be O(n)</li>
<li>Pros
<ul>
<li>better than O(n)</li>
<li>ordered</li>
<li>Flexible size</li>
</ul>
</li>
<li>Cons
<ul>
<li>No O(1) operation</li>
</ul>
</li>
</ul>
<h3 id="the-difference-of-implementation-between-array-and-linked-list">The difference of implementation between Array and Linked List</h3>
<ul>
<li>Array: Need to move several nodes when a node is added or deleted.</li>
<li>Linked List: Improve the drawback of Array.</li>
</ul>
<h3 id="how-to-remove-a-node-in-bst">How to remove a node in BST</h3>
<p><code>insert</code> and <code>lookup</code> a node is quite easy, but removing a node is complex.</p>
<p>3 cases</p>
<ul>
<li>no child: just delete</li>
<li>1 child: replace the targetted node with its child node</li>
<li>2 children: there are 2 options to do that (so that the tree can continue to follow the rules of BST).
<ul>
<li>find the minimum value in right subtree, assign it to the node we want to delete (most common)</li>
<li>find the maximum value in left subtree, assign it to the node we want to delete</li>
</ul>
</li>
</ul>
<p>no child</p>
<pre><code>         100                                100
        /    \                             /
      75     125 &lt;- remove      =&gt;       75
</code></pre>
<p>1 child</p>
<pre><code>                100                         100
                /                           /
    remove -&gt; 75              =&gt;          65
             /                            /\
           65                           60  70
           /\
         60  70
</code></pre>
<p>1 child</p>
<pre><code>                3                         3
               / \                       / \
    remove -&gt; 1   4           =&gt;        2   4
               \
                2
</code></pre>
<p>1 child</p>
<pre><code>       3                             3
      / \                           / \
     1   5 &lt;- remove     =&gt;        1   4
        /
       4
</code></pre>
<p>2 children (leftmost in right subtree is 70)</p>
<pre><code>                    75                      75
                   /  \                    /  \
       remove -&gt; 65    85       =&gt;       70    85
                 /\                     /
               60  70                  60
</code></pre>
<p>2 children (leftmost in right subtree is 115)</p>
<pre><code>           100 &lt;- remove                     115
          /   \                             /  \
        75     125               =&gt;       75    125
              /   \                               \
            115    150                            150
</code></pre>
<p>2 children (leftmost in right subtree is 80)</p>
<pre><code>                     100                            100
                     /  \                          /   \
         remove -&gt; 75    125                     80     125
                 /    \          =&gt;            /    \
               65      85                    65      85
              /  \    /  \                  /  \       \
            60   70  80  95               60   70       95
</code></pre>
<p>2 children (leftmost in right subtree is 135)</p>
<pre><code>            100                             100
           /   \                           /   \
         75     125 &lt;- remove            75     135
               /   \             =&gt;            /   \
            115     150                      115   150
                   /   \                             \
                 135   175                           175
</code></pre>
<p>2 children (leftmost in right subtree is 34)</p>
<pre><code>            2                                   2
          /   \                               /   \
         0     33 &lt;- remove                 0      34
              /  \                                /  \
            25    40                            25    40
                 /  \           =&gt;                   /  \
               34    45                            36    45
                 \                                /  \
                  36                            35    39
                  /\
                35  39
</code></pre>
<h1 id="heap-min-and-max">Heap (min and max)</h1>
<h3 id="difference-between-heap-and-binary-tree">Difference between heap and binary tree</h3>
<ul>
<li>heap
<ul>
<li>max-heap: root is the maximum number</li>
<li>min-heap: root is the minimum number</li>
</ul>
</li>
<li>binary tree: It doesn&rsquo;t has traits as heap does.</li>
</ul>
<h3 id="convert-to-heap-from-binary-tree">Convert to heap from binary tree</h3>
<p>Basically, put bigger value upwards and make it follow the heap&rsquo;s rule.</p>
<p>two ways to implement:</p>
<ul>
<li>from bottom to top</li>
<li>from top to bottom</li>
</ul>
<h1 id="graph">Graph</h1>
<h3 id="represent-a-graph-using-an-array">Represent a graph using an array</h3>
<p>graph:</p>
<pre><code>        2 ---------- 0
      /   \
     1-----3
</code></pre>
<p>Edge list</p>
<pre><code>graph = [[0,2], [2,3], [2,1], [1,3]]
</code></pre>
<blockquote>
<p>Each array element represents a connection between two nodes in the graph</p>
</blockquote>
<p>adjacent list</p>
<pre><code>graph = [[2], [2,3], [0,1,3], [1,2]]
</code></pre>
<blockquote>
<ul>
<li>Each array element&rsquo;s index represents a node in the graph, and the values within that element represent connections to that node.</li>
<li>For instance, the index 0 <code>[2]</code> represents a connection between nodes 0 and 2, while the index 1 <code>[2,3]</code> indicates connections between nodes 1 and 2, as well as node 1 and 3.</li>
</ul>
</blockquote>
<p>adjacent matrix</p>
<pre><code>graph = {
    [0,0,1,0],
    [0,0,1,1],
    [1,1,0,1],
    [0,1,1,0]
}
</code></pre>
<blockquote>
<ul>
<li>It has a similar concept to adjacent list.</li>
<li>The index 0 in the 2-dimensional array represents node 0 in the graph, and the presence of a value 1 at a particular index within that array element signifies a connection between node 0 and the node represented by that index.</li>
<li>For example, the index 0 <code>[0,0,1,0]</code> represents a connection between node 0 and node 2, while the index 2 <code>[1,1,0,1]</code> indicates connections betwwen node 2 and node 0, node 2 and node 1, as well as node 2 and node 3.</li>
</ul>
</blockquote>
<h1 id="deque-double-ended-queue">Deque (Double Ended Queue)</h1>
<ul>
<li>兩頭都能插入及刪除</li>
<li>同時有 stack 及 queue 的功能</li>
</ul>
<h1 id="factors-to-consider">Factors to consider</h1>
<ul>
<li>small amount of data?
<ul>
<li>Yes -&gt; amount of data predictable?
<ul>
<li>No -&gt; linked list</li>
<li>Yes -&gt; Search speed more important than insertion speed?
<ul>
<li>Yes -&gt; ordered array</li>
<li>No -&gt; unordered array</li>
</ul>
</li>
</ul>
</li>
<li>No -&gt; searching and insertion fast?
<ul>
<li>Yes -&gt; hash table</li>
<li>No -&gt; order distribution?
<ul>
<li>Yes -&gt; binary search tree</li>
<li>No -&gt; balanced tree</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ref">ref</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=_r7cfVrn28c">https://www.youtube.com/watch?v=_r7cfVrn28c</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/binary-search-tree-bst-search-insert-remove">https://www.digitalocean.com/community/tutorials/binary-search-tree-bst-search-insert-remove</a></li>
<li>Delete a node in BST <a href="https://www.youtube.com/watch?v=DkOswl0k7s4">https://www.youtube.com/watch?v=DkOswl0k7s4</a></li>
<li>Delete a node in BST <a href="https://www.educative.io/answers/how-to-delete-a-node-from-a-binary-search-tree">https://www.educative.io/answers/how-to-delete-a-node-from-a-binary-search-tree</a></li>
<li>Delete a node in BST <a href="https://www.techiedelight.com/deletion-from-bst/">https://www.techiedelight.com/deletion-from-bst/</a></li>
</ul>

</article>



</html>
