<!DOCTYPE html>
<html lang="en-us">
<title>Algorithms | Software</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.104.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/index.css">
<link rel="canonical" href="/posts/algorithms/">
<link rel="alternate" type="application/rss+xml" href="" title="Software">

<header>
  
    <a href="/" class="title">Software</a>
  
  
</header>

<article>
  <header>
    <h1>Algorithms</h1>
    <time datetime="2017-05-20T18:56:16&#43;08:00">May 20, 2017</time>
  </header>
  <h1 id="sorting-algorithm">Sorting algorithm</h1>
<p>Comparison</p>
<ul>
<li>Bubble Sort
<ul>
<li>Time O(n^2)</li>
<li>Space O(1)</li>
</ul>
</li>
<li>Insertion Sort
<ul>
<li>Time O(n^2)</li>
<li>Space O(1)</li>
</ul>
</li>
<li>Selection Sort
<ul>
<li>Time O(n^2)</li>
<li>Space O(1)</li>
</ul>
</li>
<li>Merge Sort
<ul>
<li>Time O(n log(n))</li>
<li>Space O(n)</li>
</ul>
</li>
<li>Quick Sort
<ul>
<li>Time O(n^2)</li>
<li>Space O(log(n))</li>
</ul>
</li>
</ul>
<blockquote>
<p>Can sort an type of data</p>
</blockquote>
<p>non-comparison</p>
<ul>
<li>Radix sort
<ul>
<li>Time O(nk)</li>
<li>Space O(n+k)</li>
<li>used to sort integrers or strings</li>
</ul>
</li>
<li>Counting sort
<ul>
<li>Time O(n+k)</li>
<li>Space O(k)</li>
</ul>
</li>
</ul>
<h1 id="bubble-sort">Bubble sort</h1>
<h3 id="concept">Concept</h3>
<p>Compare two values and move the larger value to the right in each iteration.
This way, the greatest value will end up on the right side in each iteration and will be locked and excluded from subsequent iterations.</p>
<h3 id="how-it-works">How it works</h3>
<p>input</p>
<pre><code>7 5 6 1 3
</code></pre>
<p>i=4, j=0, j&amp;j+1, (<code>5&lt;7</code>, swap)</p>
<pre><code>7 5 6 1 3
5 7 6 1 3
j j
</code></pre>
<p>i=4, j=1, j&amp;j+1,  (<code>7&gt;6</code>, swap)</p>
<pre><code>5 7 6 1 3
5 6 7 1 3
  j j
</code></pre>
<p>i=4, j=2, j&amp;j+1,  (<code>7&gt;1</code>, swap)</p>
<pre><code>5 6 7 1 3
5 6 1 7 3
    j j
</code></pre>
<p>i=4, j=3, j&amp;j+1,  (<code>7&gt;3</code>, swap)</p>
<pre><code>5 6 1 7 3
5 6 1 3 7
      j j
</code></pre>
<p>i=3, j=0, j&amp;j+1,  (<code>5&lt;6</code>, do nothing)</p>
<pre><code>5 6 1 3 7
j j
</code></pre>
<p>i=3, j=1, j&amp;j+1,  (<code>6&gt;1</code>, swap)</p>
<pre><code>5 6 1 3 7
5 1 6 3 7
  j j
</code></pre>
<p>i=3, j=2, j&amp;j+1,  (<code>6&gt;3</code>, swap)</p>
<pre><code>5 1 6 3 7
5 1 3 6 7
    j j
</code></pre>
<p>i=2, j=0, j&amp;j+1,  (<code>5&gt;1</code>, swap)</p>
<pre><code>5 1 3 6 7
1 5 3 6 7
j j
</code></pre>
<p>i=2, j=1, j&amp;j+1,  (<code>5&gt;3</code>, swap)</p>
<pre><code>1 5 3 6 7
1 3 5 6 7
  j j
</code></pre>
<p>i=1, j=0, j&amp;j+1,  (<code>1&lt;3</code>, do nothing)</p>
<pre><code>1 3 5 6 7
j j
</code></pre>
<p>end</p>
<h1 id="insertion-sort">Insertion sort</h1>
<h3 id="concept-1">Concept</h3>
<p>Set a starting point (i) that moves forward in each iteration after comparing all the numbers prior to it and move the smaller number to the left.</p>
<h3 id="how-it-works-1">How it works?</h3>
<p>input</p>
<pre><code>7 8 5 2 4 6 3
</code></pre>
<p>i=1, j=1, j&amp;j-1 (<code>7&lt;8</code>, do nothing)</p>
<pre><code>7 8 5 2 4 6 3
i
j j
</code></pre>
<blockquote>
<p>i is a starting point and j will be reduced by 1 in each i loop to compare 2 values</p>
</blockquote>
<p>i=2, j=2, j&amp;j-1  (<code>8&gt;5</code>, swap)</p>
<pre><code>7 8 5 2 4 6 3
7 5 8 2 4 6 3
  i
  j j
</code></pre>
<p>i=2, j=1, j&amp;j-1  (<code>7&gt;5</code>, swap)</p>
<pre><code>7 5 8 2 4 6 3
5 7 8 2 4 6 3
  i
j j
</code></pre>
<p>i=3, j=3, j&amp;j-1  (<code>8&gt;2</code>, swap)</p>
<pre><code>5 7 8 2 4 6 3
5 7 2 8 4 6 3
    i
    j j
</code></pre>
<p>i=3, j=2, j&amp;j-1  (<code>7&gt;2</code>, swap)</p>
<pre><code>5 7 2 8 4 6 3
5 2 7 8 4 6 3
    i
  j j
</code></pre>
<p>i=3, j=1, j&amp;j-1  (<code>5&gt;2</code>, swap)</p>
<pre><code>5 2 7 8 4 6 3
2 5 7 8 4 6 3
    i
j j
</code></pre>
<p>i=4, j=4, j&amp;j-1  (<code>8&gt;4</code>, swap)</p>
<pre><code>2 5 7 8 4 6 3
2 5 7 4 8 6 3
      i
      j j
</code></pre>
<p>i=4, j=3, j&amp;j-1  (<code>7&gt;4</code>, swap)</p>
<pre><code>2 5 7 4 8 6 3
2 5 4 7 8 6 3
      i
    j j
</code></pre>
<p>i=4, j=2, j&amp;j-1  (<code>5&gt;4</code>, swap)</p>
<pre><code>2 5 4 7 8 6 3
2 4 5 7 8 6 3
      i
  j j
</code></pre>
<p>i=4, j=1, j&amp;j-1  (<code>2&lt;4</code>, do nothing)</p>
<pre><code>2 4 5 7 8 6 3
      i
j j
</code></pre>
<p>i=5, j=5, j&amp;j-1  (<code>8&gt;6</code>, swap)</p>
<pre><code>2 4 5 7 8 6 3
2 4 5 7 6 8 3
        i
        j j
</code></pre>
<p>i=5, j=4, j&amp;j-1  (<code>7&gt;6</code>, swap)</p>
<pre><code>2 4 5 7 6 8 3
2 4 5 6 7 8 3
        i
      j j
</code></pre>
<p>i=5, j=3, j&amp;j-1  (<code>5&lt;6</code>, do nothing)</p>
<pre><code>2 4 5 6 7 8 3
        i
    j j
</code></pre>
<p>i=5, j=2, j&amp;j-1  (<code>4&lt;5</code>, do nothing)</p>
<pre><code>2 4 5 6 7 8 3
        i
  j j
</code></pre>
<p>i=5, j=1, j&amp;j-1  (<code>2&lt;4</code>, do nothing)</p>
<pre><code>2 4 5 6 7 8 3
        i
j j
</code></pre>
<p>i=6, j=6, j&amp;j-1  (<code>8&gt;3</code>, swap)</p>
<pre><code>2 4 5 6 7 8 3
2 4 5 6 7 3 8
          i
          j j
</code></pre>
<p>i=6, j=5, j&amp;j-1  (<code>7&gt;3</code>, swap)</p>
<pre><code>2 4 5 6 7 3 8
2 4 5 6 3 7 8
          i
        j j
</code></pre>
<p>i=6, j=4, j&amp;j-1  (<code>6&gt;3</code>, swap)</p>
<pre><code>2 4 5 6 3 7 8
2 4 5 3 6 7 8
          i
      j j
</code></pre>
<p>i=6, j=3, j&amp;j-1  (<code>5&gt;3</code>, swap)</p>
<pre><code>2 4 5 3 6 7 8
2 4 3 5 6 7 8
          i
    j j
</code></pre>
<p>i=6, j=2, j&amp;j-1  (<code>4&gt;3</code>, swap)</p>
<pre><code>2 4 3 5 6 7 8
2 3 4 5 6 7 8
          i
  j j
</code></pre>
<p>i=6, j=1, j&amp;j-1  (<code>2&gt;3</code>, do nothing)</p>
<pre><code>2 3 4 5 6 7 8
          i
j j
</code></pre>
<p>end</p>
<h1 id="selection-sort">Selection sort</h1>
<h3 id="concept-2">Concept</h3>
<p>Set a starting point (i) to find the minimum after it and swap it with the minimum.
Lock the minimum and move the start point forward in each iteration.</p>
<h3 id="how-it-works-2">How it works</h3>
<p>input</p>
<pre><code>2 8 1 3 9
</code></pre>
<p>i=0, minIdx=0, j=0, j+1 (<code>2&lt;8</code>, do nothing)</p>
<pre><code>2 8 1 3 9
i j
m
</code></pre>
<p>i=0, minIdx=0, j=1, j+1 (<code>2&gt;1</code>, to be updated)</p>
<pre><code>2 8 1 3 9
i   j
m
</code></pre>
<p>i=0, minIdx=2, j=1, j+1 (update minIdx)</p>
<pre><code>2 8 1 3 9
i   j
    m
</code></pre>
<p>i=0, midIdx=2, j=2, j+1 (<code>1&lt;3</code>, do nothing)</p>
<pre><code>2 8 1 3 9
i   m j
</code></pre>
<p>i=0, midIdx=2, j=3, j+1 (<code>1&lt;9</code>, do nothing)</p>
<pre><code>2 8 1 3 9
i   m   j
</code></pre>
<p>i=0, midIdx=2, j=3, j+1 (end of iteration, swap min with i)</p>
<pre><code>1 8 2 3 9
m   i   j
</code></pre>
<p>i=1, midIdx=1, j=1, j+1 (<code>8&gt;2</code>, to be updated)</p>
<pre><code>1 8 2 3 9
  m j
  i
</code></pre>
<p>i=1, midIdx=2, j=1, j+1 (update minIdx)</p>
<pre><code>1 8 2 3 9
  i j
    m
</code></pre>
<p>i=1, midIdx=2, j=2, j+1 (<code>2&lt;3</code>, do nothing)</p>
<pre><code>1 8 2 3 9
  i m j
</code></pre>
<p>i=1, midIdx=2, j=3, j+1 (<code>2&lt;9</code>, do nothing)</p>
<pre><code>1 8 2 3 9
  i m   j
</code></pre>
<p>i=1, midIdx=2, j=3, j+1 (end of iteration, swap min with i)</p>
<pre><code>1 2 8 3 9
  m i   j
</code></pre>
<p>i=2, midIdx=2, j=2, j+1 (<code>8&gt;3</code>, to be updated)</p>
<pre><code>1 2 8 3 9
    i j
    m
</code></pre>
<p>i=2, midIdx=3, j=2, j+1 (update midIdx)</p>
<pre><code>1 2 8 3 9
    i j
      m
</code></pre>
<p>i=2, midIdx=3, j=3, j+1 (<code>3&lt;9</code>, do nothing)</p>
<pre><code>1 2 8 3 9
    i m j
</code></pre>
<p>i=2, midIdx=3, j=3, j+1 (end of iteration, swap min with i)</p>
<pre><code>1 2 3 8 9
    m i j
</code></pre>
<p>i=3, midIdx=3, j=3, j+1 (<code>8&lt;9</code>, do nothing)</p>
<pre><code>1 2 3 8 9
      i j
      m
</code></pre>
<p>i=3, midIdx=3, j=3, j+1 (end of iteration, swap min with i)</p>
<pre><code>1 2 3 8 9
      i j
      m
</code></pre>
<p>end</p>
<h1 id="merge-sort">Merge sort</h1>
<h3 id="concept-3">Concept</h3>
<p>Divide the array into two equal-sized sub-arrays until each sub-array contains only one element. Then, merge each sub-array back into one, in order of value, until complete.</p>
<h3 id="how-it-works-3">How it works</h3>
<p>Steps</p>
<pre><code>                [6 5 3 1 8 7 2 4]
                  /           \
             [6 5 3 1]     [8 7 2 4]
              /    \         /    \
          [6 5]  [3 1]    [8 7]   [2 4]
          / \     / \      / \     / \
        [6] [5] [3] [1]  [8] [7] [2] [4]
           \ /    \ /     \ /     \ /
          [5 6]  [1 3]    [7 8]  [2 4]
              \  /          \   /
           [1 3 5 6]      [2 4 7 8]
                  \          /
               [1 2 3 4 5 6 7 8 ]
</code></pre>
<h1 id="quick-sort">Quick sort</h1>
<h3 id="concept-4">Concept</h3>
<p>Choose a pivot element, partition the data set into two sub-arrays recursively based on the pivot element,
and sort each sub-array by moving values less than the pivot to the left and values greater than the pivot to the right.
When all sub-arrays contain only one element, the entire array is considered sorted.</p>
<h3 id="how-it-works-4">How it works</h3>
<p>The process</p>
<pre><code>j
6 3 7 5 1 2 [4]    6 &gt; 4
i

  j
6 3 7 5 1 2 [4]     3 &lt; 4
i

  j
3 6 7 5 1 2 [4]     swap
i

  j
3 6 7 5 1 2 [4]     i+1
  i

    j
3 6 7 5 1 2 [4]     7 &gt; 4
  i

      j
3 6 7 5 1 2 [4]     5 &gt; 4
  i

        j
3 6 7 5 1 2 [4]     1 &lt; 4
  i

        j
3 1 7 5 6 2 [4]     swap
  i

        j
3 1 7 5 6 2 [4]     i+1
    i

          j
3 1 7 5 6 2 [4]
    i

          j
3 1 7 5 6 2 [4]     2 &lt; 4
    i

          j
3 1 2 5 6 7 [4]     swap
    i

          j
3 1 2 5 6 7 [4]     i+1
      i

             j
3 1 2 5 6 7 [4]     loop ends
      i
</code></pre>
<p>swap pivot and i</p>
<pre><code>3 1 2 [4] 6 7 5
</code></pre>
<p>Now, all elements that are less than the pivot are before it, and all elements that are greater than the pivot are after it.</p>
<p>Then divide the array into two and repeat the sorting process recursively for each part using the same steps</p>
<pre><code>[3 1 2]  4  [6 7 5]
</code></pre>
<p>and go on&hellip;</p>
<h1 id="heap-sort">Heap sort</h1>
<p>TODO</p>
<h1 id="binary-search">binary search</h1>
<ul>
<li>必須是已經排序過的陣列</li>
<li>每一次取中間位置的值, 比對大小再向左向右找</li>
<li>最佳時間複雜度：O(1)</li>
<li>平均時間複雜度：O(log n)</li>
<li>最差時間複雜度：O(log n)</li>
<li>空間複雜度：O(1)</li>
</ul>
<h3 id="depth-first-search-dfs-on-a-binary-tree">Depth First Search (DFS) on a Binary tree</h3>
<p>與 BFS 一樣是用來看這個點有沒有辦法到另一個點或是否某個點有存在在 graph 裡 (如果所有點都有連接)</p>
<ul>
<li>root node <code>&gt;</code> 左節點; root node <code>&lt;</code> 右節點</li>
<li>原理是先往左再往右找, 從深找到淺</li>
<li>深到沒有子 node 再&quot;回頭&quot;換右邊</li>
<li>如果最後回到 root node (最上層) 就代表要找的 node 沒有存在</li>
</ul>
<h1 id="interview">Interview</h1>
<h3 id="top-6-coding-interview-concepts">Top 6 Coding Interview Concepts</h3>
<ul>
<li>Heaps
<ul>
<li>min-heaps</li>
<li>max-heaps</li>
<li>K closest points to origin</li>
<li>network delay time</li>
<li>min cost to connect all points</li>
</ul>
</li>
<li>sliding window
<ul>
<li>Best time to buy/sell a stock</li>
</ul>
</li>
<li>Binary search
<ul>
<li>Guess number higher or lower</li>
<li>search a 2-D matrix</li>
<li>binary search</li>
</ul>
</li>
<li>DFS &amp; BFS
<ul>
<li>usually O(V+E), time &amp; space complexity</li>
<li>number of islands</li>
</ul>
</li>
<li>Recursion
<ul>
<li>includes Trees, Graphs, Backtracking, DP</li>
<li>N-queens</li>
</ul>
</li>
<li>Hash maps
<ul>
<li>Two sum</li>
</ul>
</li>
</ul>
<h3 id="the-10-most-important-concepts-for-coding-interviews">The 10 Most Important Concepts For Coding Interviews</h3>
<ul>
<li>logarithum</li>
<li>DFS/BFS</li>
<li>binary search</li>
<li>sliding window</li>
<li>recursion</li>
<li>inverting a binary tree and reverting a linked list</li>
<li>suffix trees</li>
<li>heaps</li>
<li>dynamic programming</li>
<li>sorting algorithum</li>
</ul>
<h4 id="ref">ref</h4>
<ul>
<li><a href="https://www.interviewcake.com/article/java/big-o-notation-time-and-space-complexity">Big O Notation</a></li>
<li><a href="https://goo.gl/mKYH19">初學者學演算法｜從時間複雜度認識常見演算法（一）</a></li>
</ul>

</article>



</html>
