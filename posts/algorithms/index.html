<!DOCTYPE html>
<html lang="en-us">
<title>Algorithms | Software engineering notes</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.104.2" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/index.css">
<link rel="canonical" href="/posts/algorithms/">
<link rel="alternate" type="application/rss+xml" href="" title="Software engineering notes">

<header>
  
    <a href="/" class="title">Software engineering notes</a>
  
  
</header>

<article>
  <header>
    <h1>Algorithms</h1>
    
  </header>
  <h1 id="bubble-sort">Bubble sort</h1>
<h3 id="how-it-works">How it works</h3>
<p>Compare two values and move the larger value to the right in each iteration.
This way, the greatest value will end up on the right side in each iteration and will be locked and excluded from subsequent iterations.</p>
<p>animated demonstration: <a href="https://commons.wikimedia.org/wiki/File:Bubble-sort-example-300px.gif">https://commons.wikimedia.org/wiki/File:Bubble-sort-example-300px.gif</a></p>
<h3 id="complexity">Complexity</h3>
<ul>
<li>Time <code>O(n^2)</code>
<ul>
<li>bubble sort works by repeatedly swapping adjacent elements if they are in the wrong order, and it continues this process until the array is sorted. The number of swaps required to sort the array is proportional to the square of the number of elements in the array</li>
</ul>
</li>
<li>Space <code>O(1)</code></li>
</ul>
<h3 id="pros-and-cons">Pros and Cons</h3>
<p>Pros</p>
<ul>
<li>Educational purposes: easy to implement</li>
<li>memory efficiency: elements are swapped in place without using additional temporary storage</li>
<li>stable sorting
<ul>
<li>For example, consider a list of records that represent people, where each record has a name and an age. If we sort the list based on age, it is important to maintain the relative order of people with the same age, so that the order of their names is preserved in the sorted list. A stable sorting algorithm, such as merge sort, would ensure that the relative order of equal elements is preserved, while an unstable sorting algorithm, such as quick sort, would not.</li>
</ul>
</li>
<li>efficient for nearly-sorted data
<ul>
<li>It takes linear time, <code>O(n)</code></li>
<li>fewer swaps, allowing the algorithm to complete more quickly.</li>
</ul>
</li>
</ul>
<p>Cons</p>
<ul>
<li>bad performance: it does not deal well with a list containing a huge number of items.
<ul>
<li>not recommended for use in practical applications due to its poor time complexity of <code>O(n^2)</code></li>
</ul>
</li>
</ul>
<h3 id="demonstration-for-unsorted-numbers">Demonstration for unsorted numbers</h3>
<p>input</p>
<pre><code>7 5 6 1 3
</code></pre>
<p>i=4, j=0, j&amp;j+1, (<code>5&lt;7</code>, swap)</p>
<pre><code>7 5 6 1 3
5 7 6 1 3
j j
</code></pre>
<p>i=4, j=1, j&amp;j+1,  (<code>7&gt;6</code>, swap)</p>
<pre><code>5 7 6 1 3
5 6 7 1 3
  j j
</code></pre>
<p>i=4, j=2, j&amp;j+1,  (<code>7&gt;1</code>, swap)</p>
<pre><code>5 6 7 1 3
5 6 1 7 3
    j j
</code></pre>
<p>i=4, j=3, j&amp;j+1,  (<code>7&gt;3</code>, swap)</p>
<pre><code>5 6 1 7 3
5 6 1 3 7
      j j
</code></pre>
<p>i=3, j=0, j&amp;j+1,  (<code>5&lt;6</code>, do nothing)</p>
<pre><code>5 6 1 3 7
j j
</code></pre>
<p>i=3, j=1, j&amp;j+1,  (<code>6&gt;1</code>, swap)</p>
<pre><code>5 6 1 3 7
5 1 6 3 7
  j j
</code></pre>
<p>i=3, j=2, j&amp;j+1,  (<code>6&gt;3</code>, swap)</p>
<pre><code>5 1 6 3 7
5 1 3 6 7
    j j
</code></pre>
<p>i=2, j=0, j&amp;j+1,  (<code>5&gt;1</code>, swap)</p>
<pre><code>5 1 3 6 7
1 5 3 6 7
j j
</code></pre>
<p>i=2, j=1, j&amp;j+1,  (<code>5&gt;3</code>, swap)</p>
<pre><code>1 5 3 6 7
1 3 5 6 7
  j j
</code></pre>
<p>i=1, j=0, j&amp;j+1,  (<code>1&lt;3</code>, do nothing)</p>
<pre><code>1 3 5 6 7
j j
</code></pre>
<p>end</p>
<h3 id="demonstration-for-sorted-numbers">Demonstration for sorted numbers</h3>
<p>input</p>
<pre><code>1 3 5 6 7
</code></pre>
<p>i=4, j=0, j&amp;j+1, (<code>1&lt;3</code>, swapped = false)</p>
<pre><code>1 3 5 6 7
j j
</code></pre>
<p>i=4, j=1, j&amp;j+1, (<code>3&lt;5</code>, swapped = false)</p>
<pre><code>1 3 5 6 7
  j j
</code></pre>
<p>i=4, j=2, j&amp;j+1, (<code>5&lt;6</code>, swapped = false)</p>
<pre><code>1 3 5 6 7
    j j
</code></pre>
<p>i=4, j=3, j&amp;j+1, (<code>6&lt;7</code>, swapped = false)</p>
<pre><code>1 3 5 6 7
      j j
</code></pre>
<p>swapped is false, then break the loop</p>
<p>end</p>
<blockquote>
<p>for sorted numbers, it only takes <code>O(n)</code></p>
</blockquote>
<h1 id="insertion-sort">Insertion sort</h1>
<h3 id="how-it-works-1">How it works</h3>
<p>Set a starting point (i) that moves forward in each iteration after comparing all the numbers prior to it and move the smaller number to the left.</p>
<p>animated demonstration: <a href="https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif">https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif</a></p>
<h3 id="complexity-1">Complexity</h3>
<ul>
<li>Time <code>O(n^2)</code>
<ul>
<li>insertion sort works by iterating over the elements in the array, and for each element, it shifts all the elements that are greater than it to the right in order to make room for it in its final position. The number of shifts required to insert each element is proportional to the number of elements that have already been processed</li>
</ul>
</li>
<li>Space <code>O(1)</code></li>
</ul>
<h3 id="pros-and-cons-1">Pros and Cons</h3>
<p>Pros</p>
<ul>
<li>efficient for nearly-sorted data
<ul>
<li>It can sort in linear time <code>O(n)</code> when the input is already sorted or nearly sorted</li>
<li>This is because the inner loop of the insertion sort algorithm, which is responsible for most of the computation, will have fewer iterations if the data is already close to being in order.</li>
<li>online sorting: For example, consider a system that generates log events in real-time and needs to sort the events based on their timestamp. An online sorting algorithm, such as insertion sort, would be a good choice in this scenario, since it can sort the events as they are generated, rather than waiting until all the events have been generated before sorting the entire array.</li>
</ul>
</li>
<li>memory efficiency: n-place, which means no auxiliary storage is necessary</li>
<li>stable sorting</li>
<li>Insertion sort algorithm is far better than selection sort algorithm
<ul>
<li>Selection sort algorithm can be used for small data sets, unfortunately Insertion sort algorithm best suitable for it.</li>
</ul>
</li>
</ul>
<p>Cons</p>
<ul>
<li>bad performance: it does not deal well with a list containing a huge number of items. <code>O(n^2)</code></li>
</ul>
<h3 id="demonstration-for-unsorted-numbers-1">Demonstration for unsorted numbers</h3>
<p>input</p>
<pre><code>7 8 5 2 4 6 3
</code></pre>
<p>i=1, j=1, j&amp;j-1 (<code>7&lt;8</code>, break loop)</p>
<pre><code>7 8 5 2 4 6 3
i
j j
</code></pre>
<blockquote>
<p>i is a starting point and j will be reduced by 1 in each i loop to compare 2 values</p>
</blockquote>
<p>i=2, j=2, j&amp;j-1  (<code>8&gt;5</code>, swap)</p>
<pre><code>7 8 5 2 4 6 3
7 5 8 2 4 6 3
  i
  j j
</code></pre>
<p>i=2, j=1, j&amp;j-1  (<code>7&gt;5</code>, swap)</p>
<pre><code>7 5 8 2 4 6 3
5 7 8 2 4 6 3
  i
j j
</code></pre>
<p>i=3, j=3, j&amp;j-1  (<code>8&gt;2</code>, swap)</p>
<pre><code>5 7 8 2 4 6 3
5 7 2 8 4 6 3
    i
    j j
</code></pre>
<p>i=3, j=2, j&amp;j-1  (<code>7&gt;2</code>, swap)</p>
<pre><code>5 7 2 8 4 6 3
5 2 7 8 4 6 3
    i
  j j
</code></pre>
<p>i=3, j=1, j&amp;j-1  (<code>5&gt;2</code>, swap)</p>
<pre><code>5 2 7 8 4 6 3
2 5 7 8 4 6 3
    i
j j
</code></pre>
<p>i=4, j=4, j&amp;j-1  (<code>8&gt;4</code>, swap)</p>
<pre><code>2 5 7 8 4 6 3
2 5 7 4 8 6 3
      i
      j j
</code></pre>
<p>i=4, j=3, j&amp;j-1  (<code>7&gt;4</code>, swap)</p>
<pre><code>2 5 7 4 8 6 3
2 5 4 7 8 6 3
      i
    j j
</code></pre>
<p>i=4, j=2, j&amp;j-1  (<code>5&gt;4</code>, swap)</p>
<pre><code>2 5 4 7 8 6 3
2 4 5 7 8 6 3
      i
  j j
</code></pre>
<p>i=4, j=1, j&amp;j-1  (<code>2&lt;4</code>, break loop)</p>
<pre><code>2 4 5 7 8 6 3
      i
j j
</code></pre>
<p>i=5, j=5, j&amp;j-1  (<code>8&gt;6</code>, swap)</p>
<pre><code>2 4 5 7 8 6 3
2 4 5 7 6 8 3
        i
        j j
</code></pre>
<p>i=5, j=4, j&amp;j-1  (<code>7&gt;6</code>, swap)</p>
<pre><code>2 4 5 7 6 8 3
2 4 5 6 7 8 3
        i
      j j
</code></pre>
<p>i=5, j=3, j&amp;j-1  (<code>5&lt;6</code>, break loop)</p>
<pre><code>2 4 5 6 7 8 3
        i
    j j
</code></pre>
<p>i=6, j=6, j&amp;j-1  (<code>8&gt;3</code>, swap)</p>
<pre><code>2 4 5 6 7 8 3
2 4 5 6 7 3 8
          i
          j j
</code></pre>
<p>i=6, j=5, j&amp;j-1  (<code>7&gt;3</code>, swap)</p>
<pre><code>2 4 5 6 7 3 8
2 4 5 6 3 7 8
          i
        j j
</code></pre>
<p>i=6, j=4, j&amp;j-1  (<code>6&gt;3</code>, swap)</p>
<pre><code>2 4 5 6 3 7 8
2 4 5 3 6 7 8
          i
      j j
</code></pre>
<p>i=6, j=3, j&amp;j-1  (<code>5&gt;3</code>, swap)</p>
<pre><code>2 4 5 3 6 7 8
2 4 3 5 6 7 8
          i
    j j
</code></pre>
<p>i=6, j=2, j&amp;j-1  (<code>4&gt;3</code>, swap)</p>
<pre><code>2 4 3 5 6 7 8
2 3 4 5 6 7 8
          i
  j j
</code></pre>
<p>i=6, j=1, j&amp;j-1  (<code>2&lt;3</code>, break loop)</p>
<pre><code>2 3 4 5 6 7 8
          i
j j
</code></pre>
<p>end</p>
<h3 id="demonstration-for-sorted-numbers-1">Demonstration for sorted numbers</h3>
<p>input</p>
<pre><code>2 3 4 5 6 7 8
</code></pre>
<p>i=1, j=1, j&amp;j-1 (<code>2&lt;3</code>, break loop)</p>
<pre><code>2 3 4 5 6 7 8
i
j j
</code></pre>
<p>i=2, j=2, j&amp;j-1  (<code>3&lt;4</code>, break loop)</p>
<pre><code>2 3 4 5 6 7 8
  i
  j j
</code></pre>
<p>i=3, j=3, j&amp;j-1  (<code>4&lt;5</code>, break loop)</p>
<pre><code>2 3 4 5 6 7 8
    i
    j j
</code></pre>
<p>i=4, j=4, j&amp;j-1  (<code>5&lt;6</code>, break loop)</p>
<pre><code>2 3 4 5 6 7 8
      i
      j j
</code></pre>
<p>i=5, j=5, j&amp;j-1  (<code>6&lt;7</code>, break loop)</p>
<pre><code>2 3 4 5 6 7 8
        i
        j j
</code></pre>
<p>i=6, j=6, j&amp;j-1  (<code>7&lt;8</code>, break loop)</p>
<pre><code>2 3 4 5 6 7 8
          i
          j j
</code></pre>
<blockquote>
<p>for sorted numbers, it only takes <code>O(n)</code></p>
</blockquote>
<h1 id="selection-sort">Selection sort</h1>
<h3 id="how-it-works-2">How it works</h3>
<p>Set a starting point (i) to find the minimum after it and swap it with the minimum.
Lock the minimum and move the starting point forward in each iteration.</p>
<h3 id="complexity-2">Complexity</h3>
<ul>
<li>Time <code>O(n^2)</code>
<ul>
<li>selection sort works by repeatedly finding the minimum element in the unsorted portion of the array and swapping it with the first unsorted element. The number of swaps required to sort the array is proportional to the square of the number of elements in the array</li>
</ul>
</li>
<li>Space <code>O(1)</code></li>
</ul>
<h3 id="pros-and-cons-2">Pros and Cons</h3>
<p>Pros</p>
<ul>
<li>memory efficiency: in-place algorithm. It does not require a lot of space for sorting</li>
</ul>
<p>Cons</p>
<ul>
<li>bad performance
<ul>
<li>It performs poorly when working on huge lists. <code>O(n^2)</code></li>
<li>Among bubble, insertion and selection, selection is the least efficient. It takes <code>O(n^2)</code> even if the numbers have been sorted already</li>
</ul>
</li>
<li>unstable algorithm</li>
</ul>
<h3 id="demonstration">Demonstration</h3>
<p>input</p>
<pre><code>2 8 1 3 9
</code></pre>
<p>i=0, minIdx=0, j=0, j+1 (<code>2&lt;8</code>, do nothing)</p>
<pre><code>2 8 1 3 9
i j
m
</code></pre>
<p>i=0, minIdx=0, j=1, j+1 (<code>2&gt;1</code>, to be updated)</p>
<pre><code>2 8 1 3 9
i   j
m
</code></pre>
<p>i=0, minIdx=2, j=1, j+1 (update minIdx)</p>
<pre><code>2 8 1 3 9
i   j
    m
</code></pre>
<p>i=0, midIdx=2, j=2, j+1 (<code>1&lt;3</code>, do nothing)</p>
<pre><code>2 8 1 3 9
i   m j
</code></pre>
<p>i=0, midIdx=2, j=3, j+1 (<code>1&lt;9</code>, do nothing)</p>
<pre><code>2 8 1 3 9
i   m   j
</code></pre>
<p>i=0, midIdx=2, j=3, j+1 (end of iteration, swap min with i)</p>
<pre><code>1 8 2 3 9
m   i   j
</code></pre>
<p>i=1, midIdx=1, j=1, j+1 (<code>8&gt;2</code>, to be updated)</p>
<pre><code>1 8 2 3 9
  m j
  i
</code></pre>
<p>i=1, midIdx=2, j=1, j+1 (update minIdx)</p>
<pre><code>1 8 2 3 9
  i j
    m
</code></pre>
<p>i=1, midIdx=2, j=2, j+1 (<code>2&lt;3</code>, do nothing)</p>
<pre><code>1 8 2 3 9
  i m j
</code></pre>
<p>i=1, midIdx=2, j=3, j+1 (<code>2&lt;9</code>, do nothing)</p>
<pre><code>1 8 2 3 9
  i m   j
</code></pre>
<p>i=1, midIdx=2, j=3, j+1 (end of iteration, swap min with i)</p>
<pre><code>1 2 8 3 9
  m i   j
</code></pre>
<p>i=2, midIdx=2, j=2, j+1 (<code>8&gt;3</code>, to be updated)</p>
<pre><code>1 2 8 3 9
    i j
    m
</code></pre>
<p>i=2, midIdx=3, j=2, j+1 (update midIdx)</p>
<pre><code>1 2 8 3 9
    i j
      m
</code></pre>
<p>i=2, midIdx=3, j=3, j+1 (<code>3&lt;9</code>, do nothing)</p>
<pre><code>1 2 8 3 9
    i m j
</code></pre>
<p>i=2, midIdx=3, j=3, j+1 (end of iteration, swap min with i)</p>
<pre><code>1 2 3 8 9
    m i j
</code></pre>
<p>i=3, midIdx=3, j=3, j+1 (<code>8&lt;9</code>, do nothing)</p>
<pre><code>1 2 3 8 9
      i j
      m
</code></pre>
<p>i=3, midIdx=3, j=3, j+1 (end of iteration, swap min with i)</p>
<pre><code>1 2 3 8 9
      i j
      m
</code></pre>
<p>end</p>
<h1 id="merge-sort">Merge sort</h1>
<h3 id="how-it-works-3">How it works</h3>
<p>Divide the array into two equal-sized sub-arrays until each sub-array contains only one element. Then, merge each sub-array back into one, in order of value, until complete.</p>
<h3 id="complexity-3">Complexity</h3>
<ul>
<li>Time <code>O(n log n)</code>
<ul>
<li>merge sort works by dividing the array into two halves, sorting each half separately, and then merging the two sorted halves back together. The merging process takes linear time proportional to the number of elements in the array, while the sorting process takes logarithmic time proportional to the number of elements in each half. The overall time complexity of merge sort is <code>O(n log n)</code> because the number of elements in each half is reduced by half with each iteration of the sorting process.</li>
</ul>
</li>
<li>Space <code>O(n)</code>
<ul>
<li>Merge sort has a space complexity of <code>O(n)</code> because it uses an auxiliary array of size n to store the sorted elements during the merging step.</li>
<li>merge sort requires an auxiliary array to store the result of each merging step. The size of this array is proportional to the number of elements in the array, which means that the space complexity of merge sort is <code>O(n)</code>. Additionally, merge sort requires a small amount of additional memory to store the recursive call stack, but this memory usage is typically not significant compared to the size of the auxiliary array.</li>
<li>It&rsquo;s worth noting that the total space complexity is <code>O(log n) + O(n)</code>
<ul>
<li>the space complexity of the call stack for the recursive calls is <code>O(log n)</code> because the array is being divided in half with each recursive call</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="pros-and-cons-3">Pros and Cons</h3>
<p>Pros</p>
<ul>
<li>Good performance
<ul>
<li>It is efficient for both small and large data sets, with a time complexity of <code>O(n log n)</code> even though worst case occurs</li>
<li>widely used in practice due to its efficient time complexity and stability</li>
</ul>
</li>
<li>Stable sorting</li>
<li>Parallel processing
<ul>
<li>can be implemented in a parallel way, which can greatly speed up sorting large data set</li>
</ul>
</li>
<li>External sorting
<ul>
<li>Merge sort is often used for external sorting, where the elements to be sorted are too large to be stored in memory all at once. In this case, the elements are divided into smaller chunks that can be sorted and merged in a two-pass process, where the first pass sorts the chunks and the second pass merges the sorted chunks into the final sorted array.</li>
</ul>
</li>
</ul>
<p>Cons</p>
<ul>
<li>use more memory: it requires more memory to store the sublists, which can be a problem with a very large list</li>
<li>slow for small arrays
<ul>
<li>For small arrays, simpler sorting algorithms like Insertion Sort can actually be faster in practice even though they have worse time complexity <code>O(n^2)</code> than Merge Sort</li>
</ul>
</li>
<li>the algorithm does the whole process even the array is already sorted</li>
<li>Marginally slower than quick sort in practise</li>
</ul>
<h3 id="demonstration-1">Demonstration</h3>
<pre><code>                [6 5 3 1 8 7 2 4]
                  /           \
             [6 5 3 1]     [8 7 2 4]
              /    \         /    \
          [6 5]  [3 1]    [8 7]   [2 4]
          / \     / \      / \     / \
        [6] [5] [3] [1]  [8] [7] [2] [4]
           \ /    \ /     \ /     \ /
          [5 6]  [1 3]    [7 8]  [2 4]
              \  /          \   /
           [1 3 5 6]      [2 4 7 8]
                  \          /
               [1 2 3 4 5 6 7 8 ]
</code></pre>
<h1 id="quick-sort">Quick sort</h1>
<h3 id="how-it-works-4">How it works</h3>
<p>Choose a pivot element, partition the data set into two sub-arrays recursively based on the pivot element,
and sort each sub-array by moving values less than the pivot to the left and values greater than the pivot to the right.
When all sub-arrays contain only one element, the entire array is considered sorted.</p>
<h3 id="complexity-4">Complexity</h3>
<ul>
<li>Time
<ul>
<li>(avg) <code>O(n log n)</code>
<ul>
<li>The pivot is then used as a pivot for recursive calls on the two partitioned subarrays. When the pivot is chosen optimally and the array is randomly shuffled, the size of each partition is roughly equal, which results in a good average time complexity of <code>O(n log n)</code></li>
</ul>
</li>
<li>(worse) <code>O(n^2)</code>
<ul>
<li>if the pivot is always chosen poorly, the time complexity of quick sort can be <code>O(n^2)</code>, which makes its time complexity heavily dependent on the choice of pivot.</li>
</ul>
</li>
</ul>
</li>
<li>Space
<ul>
<li>it&rsquo;s tied to the maximum height of the recursion tree</li>
<li>(avg) <code>O(log n)</code>
<ul>
<li>In the average case, when the pivot is chosen optimally and the array is randomly shuffled, the size of each partition is roughly equal, which results in a good average space complexity of <code>O(log n)</code>.</li>
<li>This is because quick sort uses a recursive approach, where each recursive call uses a small amount of memory proportional to the size of the call stack.</li>
<li><code>O(1)</code> space for each recursive call and the height of the recursion tree is proportional to <code>O(log n)</code></li>
<li>It is due to the additional memory needed to store the intermediate state of the recursion (for function call stack).</li>
</ul>
</li>
<li>(worse) <code>O(n)</code>
<ul>
<li>where <code>n</code> is the number of elements in the array (height of tree)</li>
<li>if the pivot is always chosen poorly, the size of one partition can be much larger than the other, which results in a call stack with a height proportional to the number of elements in the array, resulting in a worst-case space complexity of <code>O(n)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="pros-and-cons-4">Pros and Cons</h3>
<p>Pros</p>
<ul>
<li>Good performance
<ul>
<li>Quick sort is highly efficient among all sorting algorithms</li>
<li>widely used in practice</li>
<li>fast in most cases</li>
</ul>
</li>
<li>memory usage: <code>O(log n)</code>
<ul>
<li>It is an in-place algorithm since it just requires a modest auxiliary stack. <code>O(log n)</code></li>
<li>quicksort requires little space</li>
</ul>
</li>
<li>Parallel processing
<ul>
<li>during each call of QUICKSORT, the array is partitioned into two parts and each part is solved recursively.</li>
<li>Sorting the smaller arrays represents two completely independent subproblems that can be solved in parallel.</li>
<li>Therefore, one way to parallelize quicksort is to execute it initially on a single process; then, when the algorithm performs its recursive calls, assign one of the subproblems to another process.</li>
<li>Now each of these processes sorts its array by using quicksort and assigns one of its subproblems to other processes</li>
</ul>
</li>
</ul>
<p>Cons</p>
<ul>
<li>unstable sorting
<ul>
<li>it swaps non-adjacent elements.</li>
</ul>
</li>
<li>worse case: <code>O(n^2)</code>
<ul>
<li>if you always choose the first or last array element as the pivot, then Quicksort takes N^2 time to sort an already-sorted array</li>
<li>slowest sort if things are already in reverse-order <code>O(n^2)</code></li>
<li>On sorted and nearly-sorted arrays, its performance is slower than standard InsertionSort</li>
</ul>
</li>
</ul>
<h3 id="demonstration-2">Demonstration</h3>
<pre><code>j
6 3 7 5 1 2 [4]    6 &gt; 4
i

  j
6 3 7 5 1 2 [4]     3 &lt; 4
i

  j
3 6 7 5 1 2 [4]     swap
i

  j
3 6 7 5 1 2 [4]     i+1
  i

    j
3 6 7 5 1 2 [4]     7 &gt; 4
  i

      j
3 6 7 5 1 2 [4]     5 &gt; 4
  i

        j
3 6 7 5 1 2 [4]     1 &lt; 4
  i

        j
3 1 7 5 6 2 [4]     swap
  i

        j
3 1 7 5 6 2 [4]     i+1
    i

          j
3 1 7 5 6 2 [4]
    i

          j
3 1 7 5 6 2 [4]     2 &lt; 4
    i

          j
3 1 2 5 6 7 [4]     swap
    i

          j
3 1 2 5 6 7 [4]     i+1
      i

             j
3 1 2 5 6 7 [4]     loop ends
      i
</code></pre>
<p>swap pivot and i</p>
<pre><code>3 1 2 [4] 6 7 5
</code></pre>
<p>Now, all elements that are less than the pivot are before it, and all elements that are greater than the pivot are after it.</p>
<p>Then divide the array into two and repeat the sorting process recursively for each part using the same steps</p>
<pre><code>[3 1 2]  4  [6 7 5]
</code></pre>
<p>and so on&hellip;</p>
<h3 id="its-in-place-algorithm-why-does-it-require-extra-space">It&rsquo;s in-place algorithm, why does it require extra space?</h3>
<p>It doesn&rsquo;t require an additional array to perform the sorting operation</p>
<p>However, QuickSort is a recursive algorithm, and each recursive call requires a small amount of memory that is allocated on the call stack, a system-provided data structure that tracks function calls.</p>
<p>Each recursive call to QuickSort is a new &ldquo;layer&rdquo; on the call stack, and the maximum depth of these layers is what gives rise to the space complexity of QuickSort.</p>
<p>The amount of memory used does not depend on the size of the input to the function (which is why we say it&rsquo;s a constant amount), but on the number of recursive calls</p>
<p>So each recursive call to the QuickSort function requires a constant amount of space for its stack frame</p>
<h1 id="heap-sort">Heap sort</h1>
<h3 id="how-it-works-5">How it works</h3>
<ol>
<li>Build an max-heap/min-heap first from given unsorted array using the same idea of <code>heapify</code></li>
<li>In each iteration, swap the maximum with the last element, then run <code>heapify</code> to sort unsorted elements (exclude the elements that are shifted to the right)
<ul>
<li>pop the maximum, then heapify the rest of the elements</li>
</ul>
</li>
<li>Until the heap size reduces to 1, all elements are sorted</li>
</ol>
<h3 id="complexity-5">Complexity</h3>
<ul>
<li>Time <code>O(n log n)</code>
<ul>
<li>it takes <code>O(log n)</code> time to maintain the min-heap property by swapping elements down the tree as necessary</li>
</ul>
</li>
<li>Space <code>O(1)</code>
<ul>
<li>The algorithm swaps elements within the original array, so no extra memory is needed to store intermediate results</li>
</ul>
</li>
</ul>
<h3 id="pros-and-cons-5">Pros and Cons</h3>
<p>Pros</p>
<ul>
<li>Efficiency &amp; Consistency
<ul>
<li>a better average-case time complexity of <code>O(n log n)</code></li>
</ul>
</li>
<li>Memory usage is less: it doesn&rsquo;t require any extra space to sort an array <code>O(1)</code></li>
</ul>
<p>Cons</p>
<ul>
<li>unstable sort: not a stable sorting algorithm</li>
<li>Expensive constant factors
<ul>
<li>In the case of Heapsort vs. Quicksort, it turns out that there are ways (median of 5, for example) to make Quicksort&rsquo;s worst cases very rare indeed</li>
<li>Also, maintaining a heap is not free.</li>
<li>Given an array with a normal distribution, Quicksort and Heapsort will both run in <code>O(n log n)</code>. But Quicksort will execute faster because its constant factors are smaller than the constant factors for Heapsort</li>
<li>partitioning is faster than maintaining the heap</li>
</ul>
</li>
<li>Huge datasets
<ul>
<li>If your dataset is really huge and doesn&rsquo;t fit into memory, then merge sort works like a charm. It&rsquo;s frequently used in clusters where dataset can span over hundreds of machines</li>
</ul>
</li>
</ul>
<h3 id="demonstration-part-1---make-unsorted-array-a-max-heap">Demonstration Part 1 - Make unsorted array a max-heap</h3>
<p>For an array with 9 elements, only the first 4 elements need to be heapified in order to get max-heap.
The reason why only the first 4 elements are needed is because the direction of <code>heapify</code> is downward, so the processes will take care of the whole heap</p>
<p>The example to explain above</p>
<pre><code>          -&gt; 8
           /   \
      -&gt; 27     14 &lt;-
        /  \   /  \
   -&gt; 18    9 36   55
     / \
   41   21

  [ 8, 27, 14, 18, 9, 36, 55, 41, 21 ]
    *   *   *   *
</code></pre>
<p>If there are 10 elements in the array:</p>
<pre><code>          -&gt; 8
           /   \
      -&gt; 27     14 &lt;-
        /  \   /  \
   -&gt; 18 -&gt; 9 36   55
     / \   /
   41  21 8

  [ 8, 27, 14, 18, 9, 36, 55, 41, 21, 8 ]
    *   *   *   *  *
</code></pre>
<p>Now, start to work, the input for the following demonstration</p>
<pre><code>   -&gt; 7
     / \
 -&gt; 1   2
   / \
  8   4

[7, 1, 2, 8, 4]
 *  *
</code></pre>
<blockquote>
<p>the first 2 elements will need to be heapified</p>
</blockquote>
<p>1st loop: swap value 8 with value 1 (heapify value 1)</p>
<pre><code>      7
     / \
 -&gt; 1   2
   / \
  8   4

      7
     / \
    8   2
   / \
  1   4
</code></pre>
<blockquote>
<p>the heapify is downward, so it stops here</p>
</blockquote>
<p>2nd loop: swap 7 with 8 (heapify value 7)</p>
<pre><code>   -&gt; 7
     / \
    8   2
   / \
  1   4

   -&gt; 8
     / \
    7   2
   / \
  1   4
</code></pre>
<p>max-heap is done</p>
<h3 id="demonstration-part-2---sort-the-max-heap-by-shifting-maximum-to-the-right-in-each-iteration">Demonstration Part 2 - Sort the max-heap by shifting maximum to the right in each iteration</h3>
<p>max-heap</p>
<pre><code>      8
     / \
    7   2
   / \
  1   4

  [8, 7, 2, 1, 4]
</code></pre>
<h5 id="1st-loop">1st loop</h5>
<p>shift index 0 with the last one (swap value 8 with value 4)</p>
<pre><code>      4
     / \
    7   2
   / \
  1   8

  [4, 7, 2, 1, 8]
</code></pre>
<p>do heapify for 0, 1, 2, 3 (without value 8), start with index 0</p>
<pre><code>   -&gt; 4
     / \
    7   2
   /
  1

  [4, 7, 2, 1, 8]
</code></pre>
<p>swap value 4 and value 7</p>
<pre><code>      7
     / \
 -&gt; 4   2
   /
  1

  [7, 4, 2, 1, 8]
</code></pre>
<p>do heapify, start from value 4</p>
<pre><code>      7
     / \
 -&gt; 4   2
   /
  1

  [7, 4, 2, 1, 8]
</code></pre>
<p>done (4 &gt; 1, do nothing)</p>
<h5 id="2nd-loop">2nd loop</h5>
<p>swap value 7 with value 1</p>
<pre><code>      1
     / \
    4   2
   /
  7

  [1, 4, 2, 7, 8]
</code></pre>
<p>do heapify for index 0, 1, 2 (without value 7), start from value 1</p>
<pre><code>   -&gt; 1
     / \
    4   2

  [1, 4, 2, 7, 8]
</code></pre>
<p>swap value 1 and value 4</p>
<pre><code>      4
     / \
 -&gt; 1   2

  [4, 1, 2, 7, 8]
</code></pre>
<h5 id="3rd-loop">3rd loop</h5>
<p>swap value 2 with value 4</p>
<pre><code>      2
     / \
    1   4

  [2, 1, 4, 7, 8]
</code></pre>
<p>do heapify for index 0, 1 (without value 4), start from value 2</p>
<pre><code>   -&gt; 2
     /
    1

  [2, 1, 4, 7, 8]
</code></pre>
<p>done (2 &gt; 1, do nothing)</p>
<h5 id="4th-loop">4th loop</h5>
<p>swap value 1 and value 2</p>
<pre><code>      1
     /
    2

  [1, 2, 4, 7, 8]
</code></pre>
<p>done (no need to do heapify)</p>
<h1 id="counting-sort">Counting sort</h1>
<h3 id="how-it-works-6">How it works</h3>
<p>The key idea behind counting sort is to count the occurrences of each element in the input array,
and use that information to determine the correct position of each element in the output array.
This makes counting sort very efficient for data sets with a relatively small range of values,
since it avoids the need for expensive comparisons between elements.</p>
<h3 id="complexity-6">Complexity</h3>
<ul>
<li>Time <code>O(n+k)</code></li>
<li>Space <code>O(n+k)</code></li>
</ul>
<blockquote>
<p>n is the number of elements to be sorted and k is the range of values in the input array</p>
</blockquote>
<h3 id="pros-and-cons-6">Pros and Cons</h3>
<p>Pros</p>
<ul>
<li>Linear time complexity
<ul>
<li>This makes it very fast for data sets with a relatively small range of values.</li>
</ul>
</li>
<li>No comparisons needed
<ul>
<li>Unlike many other sorting algorithms, counting sort does not rely on comparisons between elements, making it more efficient for certain types of data</li>
</ul>
</li>
<li>Stable sorting</li>
<li>Easy to implement</li>
</ul>
<p>Cons</p>
<ul>
<li>Memory usage
<ul>
<li>Counting sort requires additional memory to store the counts of each element, as well as to store the sorted output array.</li>
</ul>
</li>
<li>Not an in-place sort
<ul>
<li>may not be suitable for use in situations where memory is limited</li>
</ul>
</li>
<li>Inefficient for large range of values to be sorted
<ul>
<li>Counting sort is only suitable for sorting data sets with a relatively small range of values. If the range of values is too large, the memory requirements of counting sort can become wasteful.</li>
</ul>
</li>
<li>It&rsquo;s designed to work with integer (not suitable for decimal)</li>
</ul>
<h3 id="demonstration-3">Demonstration</h3>
<p>input</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
</code></pre>
<blockquote>
<p>min = 18, max = 25, size of count array = 8 (25-18+1)</p>
</blockquote>
<p>Create a count array</p>
<pre><code> index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
</code></pre>
<p>Fill the count array with the number of occurrences</p>
<pre><code> index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  0  |  0  |  2  |  0  |  0  |  0  |  1  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
</code></pre>
<p>Sum up values with predecessor values</p>
<pre><code> index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  3  |  3  |  3  |  3  |  4  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
</code></pre>
<p>Create a sorted array with the same length as origin input</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  |  0  |  0  |  0  |  0  |
         -----------------------
</code></pre>
<p>Now, start to fill the sorted array</p>
<p>To make sure this algorithm performs stable sorting, start with the last element <code>21</code> from the input</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------


 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  3  |  3  |  3  |  3  |  4  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)


 index     0     1     2     3
         -----------------------
 value  |  0  |  0  |  0  |  0  |
         -----------------------
</code></pre>
<p>Find the value of the count array <code>3</code> via value <code>21</code> from input array</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
                             |
                             |
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  3  |  3  |  3  |  3  |  4  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)


 index     0     1     2     3
         -----------------------
 value  |  0  |  0  |  0  |  0  |
         -----------------------
</code></pre>
<p>Fill the sorted array with <code>21</code> at the index <code>2</code>, which comes from the value of count array <code>3</code> minus <code>1</code>.</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
                             |
                             |
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  3  |  3  |  3  |  3  |  4  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
                         ____/
                        /
 index     0     1     2     3
         -----------------------
 value  |  0  |  0  | 21  |  0  |
         -----------------------
</code></pre>
<p>Update the value of count array to 2 (<code>3</code>-<code>1</code>)</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
                             |
                             |
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  2  |  3  |  3  |  3  |  4  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
                         ____/
                        /
 index     0     1     2     3
         -----------------------
 value  |  0  |  0  | 21  |  0  |
         -----------------------
</code></pre>
<p>Then next value is <code>25</code>. Find the value of count array using the same step</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
                        \___________________________
                                                    \
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  2  |  3  |  3  |  3  |  4  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)


 index     0     1     2     3
         -----------------------
 value  |  0  |  0  | 21  |  0  |
         -----------------------
</code></pre>
<p>Find the index of sorted array <code>3</code> via the value of count array (<code>4</code> minus <code>1</code>)</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
                        \___________________________
                                                    \
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  2  |  3  |  3  |  3  |  4  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
                               ______________________/
                              /
 index     0     1     2     3
         -----------------------
 value  |  0  |  0  | 21  |  0  |
         -----------------------
</code></pre>
<p>Update the sorted array and count array</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
                        \___________________________
                                                    \
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  2  |  3  |  3  |  3  |  3  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
                               ______________________/
                              /
 index     0     1     2     3
         -----------------------
 value  |  0  |  0  | 21  | 25  |
         -----------------------
</code></pre>
<p>Next, the value <code>21</code></p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
                  \_________
                            \
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  2  |  3  |  3  |  3  |  3  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
                   __________/
                  /
 index     0     1     2     3
         -----------------------
 value  |  0  |  0  | 21  | 25  |
         -----------------------
</code></pre>
<p>Update the sorted array and count array</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
                  \_________
                            \
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  1  |  3  |  3  |  3  |  3  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
                   __________/
                  /
 index     0     1     2     3
         -----------------------
 value  |  0  | 21  | 21  | 25  |
         -----------------------
</code></pre>
<p>Lastly, the last value <code>18</code></p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
           |
           |
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  1  |  1  |  1  |  1  |  3  |  3  |  3  |  3  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
           |
           |
 index     0     1     2     3
         -----------------------
 value  |  0  | 21  | 21  | 25  |
         -----------------------
</code></pre>
<p>Update the sorted array and count array</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 25  | 21  |
         -----------------------
           |
           |
 index     0     1     2     3     4     5     6     7
         -----------------------------------------------
 value  |  0  |  1  |  1  |  1  |  3  |  3  |  3  |  3  |
         -----------------------------------------------
          (18)  (19)  (20)  (21)  (22)  (23)  (24)  (25)
           |
           |
 index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 21  | 25  |
         -----------------------
</code></pre>
<p>Now, all the elements are sorted</p>
<pre><code> index     0     1     2     3
         -----------------------
 value  | 18  | 21  | 21  | 25  |
         -----------------------
</code></pre>
<p>end</p>
<h1 id="binary-search">Binary search</h1>
<h3 id="how-it-works-7">How it works</h3>
<p>Find a specific value in a sorted array by repeatedly dividing the search interval in half.
It works by comparing the target value to the middle element of the array.
If the target value is less than the middle element, the search continues in the lower half of the array.
If the target value is greater than the middle element, the search continues in the upper half of the array.
The algorithm continues until the target value is found or the search interval is empty.</p>
<h3 id="complexity-7">Complexity</h3>
<p>Time: <code>O(log n)</code></p>
<h3 id="pros-and-cons-7">Pros and Cons</h3>
<p>Pros</p>
<ul>
<li>very fast compared to linear search</li>
<li>can be implemented both iteratively and recursively</li>
<li>can be applied to any sorted array or list</li>
</ul>
<p>Cons</p>
<ul>
<li>requires the input array or list to be sorted</li>
<li>can only be applied to one-dimensional sorted arrays or lists</li>
<li>not suitable for dynamic arrays or lists because inserting and deleting elements will destroy the sorted order and thus make the binary search useless</li>
</ul>
<h3 id="demonstration-4">Demonstration</h3>
<p>a sorted list, try to find <code>13</code></p>
<pre><code>1 3 4 5 13 20 25 40 42 44 53
</code></pre>
<p>find the middle <code>20</code> and compare with it</p>
<pre><code>1 3 4 5 13 20 25 40 42 44 53
           *
</code></pre>
<p>because <code>13 &lt; 20</code>, then look for the left half</p>
<pre><code>1 3 4 5 13 20 25 40 42 44 53
|        |
</code></pre>
<p>find the middle <code>4</code> on the left half, then look for the right half as <code>13 &gt; 4</code></p>
<pre><code>1 3 4 5 13 20 25 40 42 44 53
|   *    |
</code></pre>
<p>find the middle <code>5</code> on the left half, then look for the right half as <code>13 &gt; 5</code></p>
<pre><code>1 3 4 5 13 20 25 40 42 44 53
    | *  |
</code></pre>
<p>find the node <code>13</code></p>
<pre><code>1 3 4 5 13 20 25 40 42 44 53
        *
</code></pre>
<p>end</p>
<h1 id="traversal">Traversal</h1>
<h3 id="bfs-breadth-first-search">BFS (Breadth First Search)</h3>
<p>tree</p>
<pre><code>            9
          /   \
        4      20
       / \    /  \
      1   6  15   170
</code></pre>
<p>traversal</p>
<pre><code>9 4 20 1 6 15 170
</code></pre>
<blockquote>
<p>time complexity is <code>O(n)</code></p>
</blockquote>
<p>Pros</p>
<ul>
<li>If Solution exists BFS will definitely find it</li>
<li>easy to find the shortest path between two nodes because BFS visits nodes level-by-level, and it will find the destination node as soon as it is encountered</li>
<li>Never get trapped in unwanted nodes without the solution</li>
<li>useful for finding the maximum or minimum value in a BST</li>
</ul>
<p>Cons</p>
<ul>
<li>BFS uses more memory than DFS because it needs to keep track of all nodes at the same level before moving on to deeper levels (e.g. queue)</li>
<li>Slower for deep trees (a higher time complexity than DFS because it visits all nodes at the same level before moving on to the next level)</li>
</ul>
<p>use cases</p>
<ul>
<li>find BT nodes</li>
<li>search engine use BFS to build index</li>
<li>GPS navigation</li>
<li>Network problems: BFS can be used to find the shortest path in a network. For example, it can be used to find the shortest path between two nodes in a computer network, or to find the shortest path between two nodes in a social network.</li>
<li>Map problems: BFS can be used to find the shortest path in a map.</li>
<li>recommendation engine
<ul>
<li>on Amazon: what types of items are related or the closet relation to the last book I bought</li>
<li>on FB: what types of friend requests I should be recommended</li>
</ul>
</li>
</ul>
<h3 id="dfs-depth-first-search">DFS (Depth First Search)</h3>
<p>tree</p>
<pre><code>            9
          /   \
        4      20
       / \    /  \
      1   6  15   170
</code></pre>
<p>traversal</p>
<pre><code>9 4 1 6 20 15 170
</code></pre>
<blockquote>
<p>The time complexity is <code>O(n)</code> regardless of the traversal method used</p>
</blockquote>
<p>Pros</p>
<ul>
<li>Memory efficiency: DFS uses a stack to store nodes to be processed, which only requires a limited amount of memory compared to BFS, which uses a queue and requires more memory.</li>
<li>Faster for deep trees because it can quickly reach the bottom-most level of a tree.</li>
<li>Faster in finding a solution: DFS can backtrack and quickly eliminate branches that do not contain a solution especially if the solution is located deep in the graph. For example, consider a problem where you need to find a specific node in a large graph. With DFS, you can start from a node and follow its edges to explore deeper into the graph. If you find the solution, you can stop the search and return the result.</li>
</ul>
<p>Cons</p>
<ul>
<li>Can get stuck in an infinite loop: If there are cycles in the graph, DFS may get stuck in an infinite loop, whereas BFS is able to avoid this issue.</li>
<li>Cannot guarantee to find a solution. For example, if we search for Starbucks from my location, it will definitely find one soon. but if we search for a museum, then it will take more time and might not guarantee to find one.</li>
<li>Cannot find the minimal solution if two solutions are available</li>
<li>Slower for shallow trees</li>
</ul>
<p>use cases</p>
<ul>
<li>If we perform DFS on unweighted graph, then it will create minimum spanning tree for all pair shortest path tree</li>
<li>Using DFS we can find path between two given vertices u and v.</li>
<li>topological sorting: Topological sorting is a linear ordering of the vertices in a directed acyclic graph (DAG) (e.g. A-&gt;B-&gt;C-&gt;D)
<ul>
<li>scheduling problems: can be used to schedule jobs from given dependencies among jobs</li>
</ul>
</li>
<li>solving puzzles with only one solution, such as a maze or a sudoku puzzle.</li>
<li>analysing networks e.g. testing if a graph is bipartite (a graph where vertices can be partitioned into two disjoint sets, with no edges connecting vertices in the same set. It&rsquo;s used in matching, scheduling, and network flow problems and can be easily tested for by coloring vertices with two colors and checking if no two adjacent vertices have the same color.)</li>
<li>on linkedin: If I have a connection someone, I can use DFS for what degree of connection with that person.</li>
</ul>
<h3 id="why-is-bfs-more-effective-in-finding-the-shortest-path-compared-to-dfs">Why is BFS more effective in finding the shortest path compared to DFS?</h3>
<ul>
<li>BFS is good at finding the shortest path in a graph or tree because it explores all the nodes at a given level before moving on to the next level.  This means that it discovers all the nodes at distance 1 from the starting node before discovering any nodes at distance 2, and so on.</li>
<li>BFS guarantees that it explores all nodes at a given distance before moving on to the next distance, it is guaranteed to find the shortest path from the starting node to any other node in the graph or tree.</li>
<li>DFS does not guarantee to find the shortest path, as it explores the nodes along a single path until it reaches a dead end before backtracking and exploring other paths.</li>
</ul>
<h3 id="inorder-vs-preorder-vs-postorder">inorder vs preorder vs postorder</h3>
<ul>
<li>preorder (root, left, right)
<ul>
<li>If you know you need to explore the roots before inspecting any leaves, you pick pre-order because you will encounter all the roots before all of the leaves.</li>
</ul>
</li>
<li>inorder (left, root, right)
<ul>
<li>If you know that the tree has an inherent sequence in the nodes, and you want to flatten the tree back into its original sequence, than an in-order traversal should be used.</li>
</ul>
</li>
<li>postorder (left, right, root)
<ul>
<li>If you know you need to explore all the leaves before any nodes, you select post-order because you don&rsquo;t waste any time inspecting roots in search for leaves.</li>
</ul>
</li>
</ul>
<p>Example 1</p>
<pre><code>            9
          /   \
        4      20
       / \    /  \
      1   6  15   170
</code></pre>
<p>preorder</p>
<pre><code>9 4 1 6 20 15 170
</code></pre>
<p>inorder</p>
<pre><code>1 4 6 9 15 20 170
</code></pre>
<p>postorder</p>
<pre><code>1 6 4 15 170 20 9
</code></pre>
<p>Example 2</p>
<pre><code>              50
            /    \
          /        \
       30           80
      /  \        /    \
     1    47    70      100
         /  \     \     / \
       40    73    78  99  126
      /  \        /  \     /
     38  45      75  79  118
</code></pre>
<p>preorder</p>
<pre><code>50 30 1 47 40 38 45 73 80 70 78 75 79 100 99 126 118
</code></pre>
<p>inorder</p>
<pre><code>1 30 38 40 45 47 73 50 70 75 78 79 80 99 100 118 126
</code></pre>
<p>postorder</p>
<pre><code>1 38 45 40 73 47 30 75 79 78 70 99 118 126 100 80 50
</code></pre>
<h3 id="why-does-bfs-not-have-inorder-preorder-and-postorder-implementations-while-dfs-does">Why does BFS not have inorder, preorder, and postorder implementations, while DFS does?</h3>
<ul>
<li>BFS visits nodes in a level-by-level manner, which makes it difficult to visit the nodes in a specific order.</li>
<li>DFS has inorder, preorder, and postorder implementations because it can be used to traverse the tree and visit the nodes in a specific order by visiting the children of a node before visiting the node itself.</li>
</ul>
<h1 id="whats-the-pros-and-cons-of-recursive-solution">What&rsquo;s the pros and cons of recursive solution?</h1>
<p>Pros</p>
<ul>
<li>reduce time complexity (if use recursion with memorisation)</li>
<li>cleaner code</li>
<li>Recursion is better at tree traversal
<ul>
<li>One of the more efficient ways to traverse these trees when looking for a specific leaf (or node) is by recursively following a single branch until the end of that branch until you find the value you are looking for.</li>
</ul>
</li>
</ul>
<p>Cons</p>
<ul>
<li>use more memory (might cause stack overflow)
<ul>
<li>Because the function has to add to the stack with each recursive call and keep the values there until the call is finished</li>
</ul>
</li>
<li>can be slow (generally, compare to iteration)
<ul>
<li>it requires the allocation of a new stack frame</li>
<li>fibonacci question is a good example. Iteration is much faster than recursion, because iteration saves the value of each calculation for further use.</li>
</ul>
</li>
<li>more difficult to understand and debug</li>
</ul>
<h1 id="other-algorithms">Other algorithms</h1>
<ul>
<li>Tree sort
<ul>
<li>Steps
<ul>
<li>Create a binary search tree from an array</li>
<li>Do an in-order traversal</li>
</ul>
</li>
</ul>
</li>
<li>Radix sort
<ul>
<li>Time <code>O(nk)</code></li>
<li>Space <code>O(n+k)</code></li>
<li>used to sort integrers or strings</li>
</ul>
</li>
</ul>
<h3 id="shortest-path-of-a-weighted-graph">shortest path (of a weighted graph)</h3>
<ul>
<li>Bellman-Ford
<ul>
<li>support negative weight</li>
</ul>
</li>
<li>Dijkstra</li>
</ul>
<h1 id="terms">Terms</h1>
<h3 id="dynamic-programming">Dynamic Programming</h3>
<ul>
<li>Aim to find the best solution among a set of possible solutions</li>
<li>It is mainly used when the problem can be broken down into overlapping subproblems, and the optimal solutions of these subproblems can be used iteratively to solve the overall problem
<ul>
<li>to solve each subproblem only once, rather than repeatedly</li>
</ul>
</li>
<li>= Divide &amp; Conquer + Memoisation</li>
</ul>
<h3 id="functional-programming">Functional Programming</h3>
<ul>
<li>uses pure functions to create maintainable software</li>
<li>uses immutable data and avoids concepts like shared states (opposite to OOP)</li>
<li>focuses on the results, not the process</li>
<li>make code easier to understand, test, and debug</li>
<li>independent and reusable</li>
</ul>
<h1 id="interview">Interview</h1>
<h3 id="top-6-coding-interview-concepts">Top 6 Coding Interview Concepts</h3>
<ul>
<li>Heaps
<ul>
<li>min-heaps</li>
<li>max-heaps</li>
<li>K closest points to origin</li>
<li>network delay time</li>
<li>min cost to connect all points</li>
</ul>
</li>
<li>sliding window
<ul>
<li>Best time to buy/sell a stock</li>
</ul>
</li>
<li>Binary search
<ul>
<li>Guess number higher or lower</li>
<li>search a 2-D matrix</li>
<li>binary search</li>
</ul>
</li>
<li>DFS &amp; BFS
<ul>
<li>usually <code>O(V+E)</code>, time &amp; space complexity</li>
<li>number of islands</li>
</ul>
</li>
<li>Recursion
<ul>
<li>includes Trees, Graphs, Backtracking, DP</li>
<li>N-queens</li>
</ul>
</li>
<li>Hash maps
<ul>
<li>Two sum</li>
</ul>
</li>
</ul>
<h3 id="the-10-most-important-concepts-for-coding-interviews">The 10 Most Important Concepts For Coding Interviews</h3>
<ul>
<li>logarithum</li>
<li>DFS/BFS</li>
<li>binary search</li>
<li>sliding window</li>
<li>recursion</li>
<li>inverting a binary tree and reverting a linked list</li>
<li>suffix trees</li>
<li>heaps</li>
<li>dynamic programming</li>
<li>sorting algorithum</li>
</ul>
<h4 id="ref">ref</h4>
<ul>
<li><a href="https://www.interviewcake.com/article/java/big-o-notation-time-and-space-complexity">Big O Notation</a></li>
<li><a href="https://www.quora.com/What-are-the-advantages-of-using-BFS-over-DFS-or-using-DFS-over-BFS-What-are-the-applications-and-downsides-of-each">bfs vs dfs</a></li>
<li><a href="https://www.tutorialspoint.com/applications-of-dfs-and-bfs-in-data-structures">use cases of BFS/DFS</a></li>
<li><a href="https://medium.com/@williambdale/recursion-the-pros-and-cons-76d32d75973a">recursive</a></li>
<li><a href="https://stackoverflow.com/questions/9456937/when-to-use-preorder-postorder-and-inorder-binary-search-tree-traversal-strate">preorder vs inorder vs postorder</a></li>
<li>chatGPT</li>
</ul>

</article>



</html>
